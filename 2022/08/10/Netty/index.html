<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/avatar.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Anrozz炫"><meta name="keywords" content=""><meta name="description" content="学会使用netty并调优"><meta property="og:type" content="article"><meta property="og:title" content="Netty"><meta property="og:url" content="https://study-nodes.vercel.app/2022/08/10/Netty/index.html"><meta property="og:site_name" content="AnrozzX"><meta property="og:description" content="学会使用netty并调优"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/cover/Netty.jpg"><meta property="article:published_time" content="2022-08-09T16:08:00.000Z"><meta property="article:modified_time" content="2022-08-09T16:12:14.695Z"><meta property="article:author" content="Anrozz炫"><meta property="article:tag" content="Java"><meta property="article:tag" content="Netty"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/cover/Netty.jpg"><title>Netty - AnrozzX</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"study-nodes.vercel.app",root:"/",version:"1.8.14",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"WjHIDOqzb1daY6OtrltW0izN-gzGzoHsz",app_key:"BmmacmxlOzYnoNfkcBoAMO16",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/"><strong>Anrozz炫の博客</strong></a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"> <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/cover/Netty.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Netty"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Anrozz炫</span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-10 00:08" pubdate>2022年8月10日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 42k 字</span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 352 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Netty</h1><div class="markdown-body"><p><strong>学会使用netty并调优</strong></p><span id="more"></span><p>学自《跟闪电侠学 Netty：Netty 即时聊天实战与底层原理》</p><blockquote><p>文档更新于: 2022-8-10 0:08</p></blockquote><h1 id="第-1-章-即时聊天系统简介"><a href="#第-1-章-即时聊天系统简介" class="headerlink" title="第 1 章 即时聊天系统简介"></a>第 1 章 即时聊天系统简介</h1><p>​ 移动互联网时代，相信大家应该都对即时聊天工具不陌生，比如最常用的微信，从2011年1月21日诞生至今，已经成为国内数亿用户必不可少的即时通信工具，是男女老少手机中必备的顶级App。Netty是一个异步基于事件驱动的高性能网络通信框架，在互联网中间件领域网络通信层是无可争议的最强王者。在本书中，笔者将带领大家使用Netty一步一步实现即时聊天工具的核心功能。<br>即时聊天通常分为单聊和群聊，下面分别来介绍一下。</p><h2 id="1-1单聊流程"><a href="#1-1单聊流程" class="headerlink" title="1.1	单聊流程"></a>1.1 单聊流程</h2><p>​ 单聊指两个用户之间相互聊天。用户单聊的基本流程如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit.jpeg" srcset="/img/loading.gif" lazyload alt="用户单聊的基本流程"></p><ol><li>A要和B聊天，首先A和B需要与服务端建立连接，然后进入登录流程，服务端保存用户标识和TCP连接的映射关系。</li><li>A给B发消息，首先需要将带有B标识的消息数据包发送到服务端，然后服务端从消息数据包中获得B的标识，找到对应B的连接，将消息发送给B。</li><li>任意一方发消息给对方，如果对方不在线，则需要将消息缓存，在对方上线之后再发送。<br>客户端与服务端之间相互通信的数据包被称为指令数据包。指令数据包分为指令和数据，每一种指令都对应客户端或者服务端的一种操作，数据部分对应的是指令处理需要的数据。</li></ol><p><strong>问题</strong>：要实现单聊，客户端与服务端分别要实现哪些指令呢？</p><h2 id="1-2单聊的指令"><a href="#1-2单聊的指令" class="headerlink" title="1.2	单聊的指令"></a>1.2 单聊的指令</h2><h3 id="1-2-1-指令图示"><a href="#1-2-1-指令图示" class="headerlink" title="1.2.1　指令图示"></a>1.2.1　指令图示</h3><p>​ 下图是客户端与服务端单聊的指令流程图。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600447829622.jpeg" srcset="/img/loading.gif" lazyload alt="客户端与服务端单聊的指令流程图"></p><h3 id="1-2-2-指令列表"><a href="#1-2-2-指令列表" class="headerlink" title="1.2.2　指令列表"></a>1.2.2　指令列表</h3><p>​ 下表是要实现的单聊的指令列表，每条指令都会分为客户端和服务端。</p><table><thead><tr><th align="center">指令内容</th><th align="center">客户端</th><th align="center">服务端</th></tr></thead><tbody><tr><td align="center">登录请求</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">登录响应</td><td align="center">接收</td><td align="center">发送</td></tr><tr><td align="center">客户端发消息</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">服务端发消息</td><td align="center">接收</td><td align="center">发送</td></tr><tr><td align="center">登出请求</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">登出响应</td><td align="center">接收</td><td align="center">发送</td></tr></tbody></table><h2 id="1-3-群聊流程"><a href="#1-3-群聊流程" class="headerlink" title="1.3　群聊流程"></a>1.3　群聊流程</h2><p>​ 群聊指一个组内多个用户之间的聊天，一个用户发到群组的消息会被组内任何一个成员接收，群聊的基本流程如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600450111174.jpeg" srcset="/img/loading.gif" lazyload alt="群聊的基本流程"></p><p>​ 要实现群聊，其实流程和单聊类似。</p><ol><li>A、B、C依然会经历登录流程，服务端保存用户标识对应的TCP连接。</li><li>A发起群聊的时候，将A、B、C的标识发送至服务端，服务端拿到标识之后建立一个群ID，然后把这个ID与A、B、C的标识绑定。</li><li>群聊中任意一方在群里聊天的时候，将群ID发送至服务端，服务端获得群ID之后，取出对应的用户标识，遍历用户标识对应的TCP连接，就可以将消息发送至每一个群聊成员。</li></ol><p><strong>问题</strong>：群聊除了需要实现上述指令，还需要实现哪些指令呢？</p><h2 id="1-4-群聊要实现的指令集"><a href="#1-4-群聊要实现的指令集" class="headerlink" title="1.4　群聊要实现的指令集"></a>1.4　群聊要实现的指令集</h2><h3 id="1-4-1-指令图示"><a href="#1-4-1-指令图示" class="headerlink" title="1.4.1　指令图示"></a>1.4.1　指令图示</h3><p>​ 群聊的指令图示如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600450823416.jpeg" srcset="/img/loading.gif" lazyload alt="群聊的指令图示"></p><h3 id="1-4-2-指令列表"><a href="#1-4-2-指令列表" class="headerlink" title="1.4.2　指令列表"></a>1.4.2　指令列表</h3><p>​ 群聊的指令如下表所示。</p><table><thead><tr><th align="center">指令内容</th><th align="center">客户端</th><th align="center">服务端</th></tr></thead><tbody><tr><td align="center">创建群聊请求</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">群聊创建成功通知</td><td align="center">接收</td><td align="center">发送</td></tr><tr><td align="center">加入群聊请求</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">群聊加入通知</td><td align="center">接收</td><td align="center">发送</td></tr><tr><td align="center">发送群聊消息</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">接收群聊消息</td><td align="center">接收</td><td align="center">发送</td></tr><tr><td align="center">退出群聊请求</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">退出群聊通知</td><td align="center">接收</td><td align="center">发送</td></tr></tbody></table><h2 id="1-5-Netty"><a href="#1-5-Netty" class="headerlink" title="1.5　Netty"></a>1.5　Netty</h2><p>​ 使用 Netty 统一的 IO 读写 API 以及强大的 Pipeline 来编写业务处理逻辑，了解 Netty 以下核心知识点。<br><strong>●　如何启动服务端？</strong><br><strong>●　如何启动客户端？</strong><br><strong>●　数据载体 ByteBuf。</strong><br><strong>●　如何设计长连自定义协议？</strong><br><strong>●　拆包&#x2F;粘包原理与实践。</strong><br><strong>●　如何实现自定义编解码？</strong><br><strong>●　如何使用 Pipeline 与 ChannelHandler ？</strong><br><strong>●　如何定时发心跳数据包？</strong><br><strong>●　如何进行连接空闲检测？</strong></p><h3 id="1-5-1-客户端使用Netty的程序逻辑结构"><a href="#1-5-1-客户端使用Netty的程序逻辑结构" class="headerlink" title="1.5.1　客户端使用Netty的程序逻辑结构"></a>1.5.1　客户端使用Netty的程序逻辑结构</h3><p>​ 下图展示了客户端使用Netty的程序逻辑结构。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600453337568.jpeg" srcset="/img/loading.gif" lazyload alt="客户端Netty的程序逻辑结构"></p><ol><li>客户端会解析控制台指令，比如发送消息或者建立群聊等指令。</li><li>客户端会基于控制台的输入创建一个指令对象，用户告诉服务端具体要干什么事情。</li><li>TCP通信需要的数据格式为二进制，因此，接下来通过自定义二进制协议将指令对象封装成二进制，这一步被称为协议的编码。</li><li>对于收到服务端的数据，首先需要截取出一段完整的二进制数据包。</li><li>将此二进制数据包解析成指令对象，比如收到消息。</li><li>将指令对象送到对应的逻辑处理器来处理。</li></ol><h3 id="1-5-2-服务端使用Netty的程序逻辑结构"><a href="#1-5-2-服务端使用Netty的程序逻辑结构" class="headerlink" title="1.5.2　服务端使用Netty的程序逻辑结构"></a>1.5.2　服务端使用Netty的程序逻辑结构</h3><p>​ 服务端使用Netty的程序逻辑结构与客户端非常类似，如下图所示，这里不再赘述。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166004539765910.jpeg" srcset="/img/loading.gif" lazyload alt="服务端Netty的程序逻辑结构"></p><h2 id="1-6-实现的即时聊天形式"><a href="#1-6-实现的即时聊天形式" class="headerlink" title="1.6　实现的即时聊天形式"></a>1.6　实现的即时聊天形式</h2><p>以讲授Netty基础知识为主，故不会涉及即时聊天相关的图形化界面，后续所有的聊天都基于控制台进行，通过与控制台交互可以实现单聊和群聊。</p><h1 id="第-2-章-Netty-是什么"><a href="#第-2-章-Netty-是什么" class="headerlink" title="第 2 章 Netty 是什么"></a>第 2 章 Netty 是什么</h1><p>​ 在开始了解Netty是什么之前，我们先来回顾一下，如果需要实现一个客户端与服务端通信的程序，使用传统的IO编程，应该如何来实现？</p><h2 id="2-1-IO编程"><a href="#2-1-IO编程" class="headerlink" title="2.1　IO编程"></a>2.1　IO编程</h2><p>​ 我们简化一下场景：客户端每隔两秒发送一个带有时间戳的“hello world”给服务端，服务端收到之后打印它。<br>​ 为了方便演示，在下面的例子中，服务端和客户端各有一个类，把这两个类复制到你的IDE中，先后运行 IOServer.java 和 IOClient.java ，可以看到效果。<br>​ 下面是传统的IO编程中的服务端实现。</p><p>​ <strong>IOServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IOServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8000</span>);        <br>        <span class="hljs-comment">// 接收新连接线程        </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// (1)阻塞方法获取新连接</span><br>                    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                    <span class="hljs-comment">// (2)为每一个新连接都创建一个新线程，负责读取数据</span><br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-type">int</span> len;<br>                            <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>                            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>                            <span class="hljs-comment">// (3)按字节流方式读取数据</span><br>                            <span class="hljs-keyword">while</span> ((len = inputStream.read(data)) != -<span class="hljs-number">1</span>) &#123;<br>                                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data, <span class="hljs-number">0</span>, len));<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        &#125;<br>                    &#125;).start();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 服务端首先创建一个serverSocket来监听8000端口，然后创建一个线程，线程里不断调用阻塞方法serverSocket.accept()获取新连接，见（1）；当获得新连接之后，为每一个新连接都创建一个新线程，这个线程负责从该连接中读取数据，见（2）；然后以字节流方式读取数据，见（3）。<br>​ 下面是传统的IO编程中的客户端实现。</p><p>​ <strong>IOClient.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IOClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>);<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        socket.getOutputStream().write((<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;： helloworld&quot;</span>).getBytes());<br>                        Thread.sleep(<span class="hljs-number">2000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 客户端的代码相对简单，连接上服务端8000端口之后，每隔两秒，我们都向服务端写一个带有时间戳的“hello world”。<br>​ IO编程模型在客户端较少的情况下运行良好，但是对于客户端比较多的业务来说，单机服务端可能需要支撑成千上万个连接，IO模型可能就不太合适了，我们来分析一下原因。<br>​ 在上面的示例中，从服务端代码可以看到，在传统的IO模型中，每个连接创建成功之后都需要由一个线程来维护，每个线程都包含一个while死循环，那么1万个连接对应1万个线程，继而有1万个 while 死循环，这就带来如下几个问题。</p><ol><li>线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态，是非常严重的资源浪费，操作系统耗不起。</li><li>线程切换效率低下：单机CPU核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。</li><li>除了以上两个问题，在IO编程中，我们看到数据读写是以字节流为单位的。</li></ol><p>​ 为了解决这3个问题，JDK在1.4版本之后提出了NIO。</p><h2 id="2-2-NIO编程"><a href="#2-2-NIO编程" class="headerlink" title="2.2　NIO编程"></a>2.2　NIO编程</h2><p>​ 网上有很多关于NIO的文章，这里不再深入分析。下面简单描述一下NIO是如何解决以上3个问题的。</p><h2 id="2-2-1-线程资源受限"><a href="#2-2-1-线程资源受限" class="headerlink" title="2.2.1　线程资源受限"></a>2.2.1　线程资源受限</h2><p>​ 在NIO编程模型中，新来一个连接不再创建一个新线程，而是可以把这个连接直接绑定到某个固定的线程，然后这个连接所有的读写都由这个线程来负责，那么它是怎么做到的？我们用下图来对比一下IO与NIO。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166004622917312.jpeg" srcset="/img/loading.gif" lazyload alt="IO与NIO"></p><p>​ 如上图所示，在IO模型中，一个连接来了，会创建一个线程，对应一个while死循环，死循环的目的就是不断监测这个连接上是否有数据可以读。在大多数情况下，1万个连接里面同一时刻只有少量的连接有数据可读，因此，很多while死循环都白白浪费掉了，因为读不出数据。<br>​ 而在NIO模型中，这么多while死循环转换为一个死循环，这个死循环由一个线程控制，那么NIO又是如何做到一个线程一个while死循环就能监测1万个连接是否有数据可读的呢？<br>​ 这就是NIO模型中Selector的作用，一个连接来了之后，不会创建一个while死循环去监听是否有数据可读，而是直接把这条连接注册到Selector上。然后，通过检查这个Selector，就可以批量监测出有数据可读的连接，进而读取数据。下面我们举一个生活中非常简单的例子来说明IO与NIO的区别。<br>​ 在一家幼儿园里，小朋友有上厕所的需求，小朋友都太小以至于你要问他要不要上厕所，他才会告诉你。幼儿园一共有100个小朋友，有两种方案可以解决小朋友上厕所的问题。</p><ol><li>每个小朋友都配一个老师。每个老师都隔段时间询问小朋友是否要上厕所。如果要上，就领他去厕所，100个小朋友就需要100个老师来询问，并且每个小朋友上厕所的时候都需要一个老师领着他去，这就是IO模型，一个连接对应一个线程。</li><li>所有的小朋友都配同一个老师。这个老师隔段时间询问所有的小朋友是否有人要上厕所，然后每一时刻把所有要上厕所的小朋友批量领到厕所，这就是NIO模型。所有小朋友都注册到同一个老师，对应的就是所有的连接都注册到同一个线程，然后批量轮询。</li></ol><p>​ 这就是NIO模型解决线程资源受限问题的方案。在实际开发过程中，我们会开多个线程，每个线程都管理着一批连接，相对于IO模型中一个线程管理一个连接，消耗的线程资源大幅减少。</p><h3 id="2-2-2-线程切换效率低下"><a href="#2-2-2-线程切换效率低下" class="headerlink" title="2.2.2　线程切换效率低下"></a>2.2.2　线程切换效率低下</h3><p>​ 由于NIO模型中线程数量大大降低，因此线程切换效率也大幅度提高。</p><h3 id="2-2-3-IO读写面向流"><a href="#2-2-3-IO读写面向流" class="headerlink" title="2.2.3　IO读写面向流"></a>2.2.3　IO读写面向流</h3><p>​ IO读写是面向流的，一次性只能从流中读取一字节或者多字节，并且读完之后流无法再读取，需要自己缓存数据。而NIO的读写是面向Buffer的，可以随意读取里面任何字节数据，不需要自己缓存数据，只需要移动读写指针即可。<br>​ 简单讲完了JDK NIO的解决方案之后，接下来我们使用NIO方案替换掉IO方案。先来看看，如果用JDK原生的NIO来实现服务端，该怎么做。<br>前方高能预警：以下代码可能会让你感觉极度不适，如有不适，请跳过。</p><p>​ <strong>NIOServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 闪电侠</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">serverSelector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">clientSelector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 对应IO编程中的服务端启动</span><br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">listenerChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>                listenerChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8000</span>));<br>                listenerChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">// 监测是否有新连接，这里的1指阻塞的时间为 1ms</span><br>                    <span class="hljs-keyword">if</span> (serverSelector.select(<span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                        Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();<br>                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();<br>                        <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>                            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>                            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-comment">// (1)每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector</span><br>                                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> ((ServerSocketChannel) key.channel()).accept();<br>                                    clientChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                                    clientChannel.register(clientSelector, SelectionKey.OP_READ);<br>                                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                                    keyIterator.remove();<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">// (2)批量轮询哪些连接有数据可读，这里的1指阻塞的时间为 1ms</span><br>                    <span class="hljs-keyword">if</span> (clientSelector.select(<span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                        Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();<br>                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();<br>                        <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>                            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>                            <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                                    <span class="hljs-comment">// (3)面向Buffer                                    </span><br>                                    clientChannel.read(byteBuffer);<br>                                    byteBuffer.flip();<br>                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer));<br>                                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                                    keyIterator.remove();<br>                                    key.interestOps(SelectionKey.OP_READ);<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相信大部分没有接触过NIO的读者应该会直接跳过代码来到这一行：原来使用JDK原生NIO的API实现一个简单的服务端通信程序如此复杂!<br>我们还是先对照NIO来解释一下核心思路。</p><ol><li>NIO模型中通常会有两个线程，每个线程都绑定一个轮询器Selector。在这个例子中，serverSelector负责轮询是否有新连接，clientSelector负责轮询连接是否有数据可读。</li><li>服务端监测到新连接之后，不再创建一个新线程，而是直接将新连接绑定到clientSelector上，这样就不用IO模型中的1万个while循环死等，参见（1）。</li><li>clientSelector被一个while死循环包裹着，如果在某一时刻有多个连接有数据可读，那么通过clientSelector.select(1)方法可以轮询出来，进而批量处理，参见（2）。</li><li>数据的读写面向Buffer，参见（3）。</li></ol><p>​ 其他细节部分，因为实在是太复杂，所以笔者不再多讲，读者也不用对代码的细节深究到底。总之，强烈不建议直接基于JDK原生NIO来进行网络开发，下面是笔者总结的原因。</p><ol><li>JDK的NIO编程需要了解很多概念，编程复杂，对NIO入门非常不友好，编程模型不友好，ByteBuffer的API简直“反人类”。</li><li>对NIO编程来说，一个比较合适的线程模型能充分发挥它的优势，而JDK没有实现，需要自己实现，就连简单的自定义协议拆包都要自己实现。</li><li>JDK的NIO底层由Epoll实现，该实现饱受诟病的空轮询Bug会导致CPU占用率飙升至100%。</li><li>项目庞大之后，自行实现的NIO很容易出现各类Bug，维护成本较高，上面这些代码笔者都不能保证没有Bug。</li></ol><p>​ 正因为如此，客户端代码这里就省略了，读者可以直接使用IOClient.java与NIOServer.java通信。<br>​ JDK的NIO犹如带刺的玫瑰，虽然美好，让人向往，但是使用不当会让你抓耳挠腮，痛不欲生，正因为如此，Netty横空出世！</p><h2 id="2-3-Netty编程"><a href="#2-3-Netty编程" class="headerlink" title="2.3　Netty编程"></a>2.3　Netty编程</h2><p>​ Netty到底是何方神圣？<br>​ 用一句简单的话来说就是：Netty封装了JDK的NIO，让你用得更方便，不用再写一大堆复杂的代码了。<br>​ 用官方正式的话来说就是：Netty是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务端和客户端。<br>​ 下面是笔者总结的使用Netty而不使用JDK原生NIO的原因。</p><ol><li>使用JDK原生NIO需要了解太多概念，编程复杂，一不小心就Bug横飞。</li><li>Netty底层IO模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从NIO模型变身为IO模型。</li><li>Netty自带的拆包&#x2F;粘包、异常检测等机制让你从NIO的繁重细节中脱离出来，只需要关心业务逻辑即可。</li><li>Netty解决了JDK很多包括空轮询在内的Bug。</li><li>Netty底层对线程、Selector做了很多细小的优化，精心设计的Reactor线程模型可以做到非常高效的并发处理。</li><li>自带各种协议栈，让你处理任何一种通用协议都几乎不用亲自动手。</li><li>Netty社区活跃，遇到问题随时邮件列表或者Issue。</li><li>Netty已经历各大RPC框架、消息中间件、分布式通信中间件线上的广泛验证，健壮性无比强大。</li></ol><p>​ 这些原因看不懂没有关系，在后续的章节中我们都可以学到。接下来我们用Netty来重新实现一下本章开篇的功能吧！<br>首先引入Maven依赖，本书后续Netty都基于4.1.6.Final版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.6.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​ 然后是服务端实现部分。</p><p>​ <strong>NettyServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        serverBootstrap<br>                .group(boss, worker)<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> &#123;<br>                                System.out.println(msg);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;).bind(<span class="hljs-number">8000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 这么一小段代码就实现了我们前面NIO编程中的所有功能，包括服务端启动、接收新连接、打印客户端传来的数据，怎么样？是不是比JDK原生NIO编程简洁许多？<br>初学Netty的时候，由于大部分人对NIO编程缺乏经验，因此，将Netty里的概念与IO模型结合起来可能更好理解。</p><ol><li>boss对应IOServer.java中的负责接收新连接的线程，主要负责创建新连接。</li><li>worker对应IOServer.java中的负责读取数据的线程，主要用于读取数据及业务逻辑处理。</li></ol><p>​ 剩下的逻辑笔者在后面的内容中会详细分析，读者可以先把这段代码复制到自己的IDE里，然后运行main函数。<br>​ 下面是客户端NIO的实现部分。</p><p>​ <strong>NettyClient.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.Channel;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<br><br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        bootstrap<br>                .group(group)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(Channel ch)</span> &#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>).channel();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            channel.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;： hello world！&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 在客户端程序中，group对应了IOClient.java中main函数起的线程，剩下的逻辑在后面的内容中会详细分析，现在你要做的事情就是把这段代码复制到你的IDE里，然后运行main函数，最后回到NettyServer.java的控制台，你会看到效果。<br>​ 使用Netty之后是不是觉得整个世界都变美好了？一方面，Netty对NIO封装得如此完美，写出来的代码非常优雅；另一方面，使用Netty之后，网络通信的性能问题几乎不用操心，尽情地让Netty“榨干”你的CPU吧。</p><h1 id="第-3-章-Netty-开发环境配置"><a href="#第-3-章-Netty-开发环境配置" class="headerlink" title="第 3 章 Netty 开发环境配置"></a>第 3 章 Netty 开发环境配置</h1><p>​ 本章介绍Netty开发环境的搭建，笔者假设读者已经有了Java编程需要的环境。如果读者已经安装过Maven、Git、IntelliJ IDEA环境，建议直接看本章末尾的“如何使用本书的代码”。</p><p>本章介绍Netty开发环境的搭建，笔者假设读者已经有了Java编程需要的环境。如果读者已经安装过Maven、Git、IntelliJ IDEA环境，建议直接看本章末尾的“如何使用本书的代码”。</p><h2 id="3-1-Maven"><a href="#3-1-Maven" class="headerlink" title="3.1　Maven"></a>3.1　Maven</h2><p>Maven是一个基于对象模型来管理项目构建的项目管理工具，通过配置文件pom.xml来配置jar包，相对于传统复制jar包的方式，管理依赖更为方便，如果你没有安装过Maven，下面的指导将带你一起安装。</p><h3 id="3-1-1-下载"><a href="#3-1-1-下载" class="headerlink" title="3.1.1　下载"></a>3.1.1　下载</h3><p>首先，到Apache官网下载Maven，由于Maven也是使用Java编写的，所以不同操作系统下载的Maven zip包是一样的，这里选择最新的版本：apache-maven-版本号-src.zip，下载到本地之后解压，接下来看不同的操作系统配置。</p><h3 id="3-1-2-配置和验证"><a href="#3-1-2-配置和验证" class="headerlink" title="3.1.2　配置和验证"></a>3.1.2　配置和验证</h3><p><strong>Windows</strong></p><ol><li>假定我们将文件夹解压到D:\maven，该目录下有bin、lib等目录。</li><li>通过“我的电脑”-&gt;“属性”-&gt;“高级系统设置”-&gt;“环境变量”-&gt;“系统变量”-&gt;“新建”新建一个环境变量，变量名为M2_HOME，值为D:\maven。</li><li>找到变量名字为Path的环境变量，在变量值的尾部加入“;%M2_HOME%\bin;”，这里需要注意前面的分号。<br>最后，打开Dos窗口，输入mvn -v，如果出来版本号相关的信息，则说明我们的Maven已经安装成功了。</li></ol><p><strong>Linux &amp;&amp; Mac</strong><br> 假定我们将文件夹解压到&#x2F;usr&#x2F;local&#x2F;maven，该目录下有bin、lib等目录；接下来，和Windows系统一样，需要配置环境变量。我们打开&#x2F;etc&#x2F;profile文件，在尾部加入下面两行代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export MAVEN_HOME=/usr/local/maven<br>PATH=$JAVA_HOME/bin：$MAVEN_HOME/bin：$PATH<br></code></pre></td></tr></table></figure><p>​ 然后，在命令行执行source &#x2F;etc&#x2F;profile，让配置生效；接下来，通过mvn -v命令来验证是否生效，如果出来的是版本号相关的信息，则说明Maven已经安装成功了。</p><h2 id="3-2-Git"><a href="#3-2-Git" class="headerlink" title="3.2　Git"></a>3.2　Git</h2><p>​ Git是一个版本管理工具，本书代码使用Git来做版本控制，每个章节的代码都是一个Git分支，方便读者循序渐进地学习。我们来看一下如何安装配置Git。</p><h3 id="3-2-1-下载与安装"><a href="#3-2-1-下载与安装" class="headerlink" title="3.2.1　下载与安装"></a>3.2.1　下载与安装</h3><p><strong>Windows</strong></p><ul><li><p>在gitforwindows.org下载最新版本的Windows Git。</p></li><li><p>下载完成之后，双击exe文件，只需要一直单击“下一步”按钮，安装即可。其中有一步需要注意一下，如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p>该步骤为调整环境变量，我们选择中间的一项，继续单击“下一步”按钮，直到安装成功。</p></li><li><p>安装成功之后，在任意目录上单击鼠标右键，选择“Git Bash Here”这一项，输入git，如果出来提示，则表明安装成功。</p></li></ul><p><strong>Linux &amp;&amp; Mac</strong></p><ul><li>如果你使用的是Debian或Ubuntu，那么直接使用一条命令sudo apt-get install git即可完成安装；如果是centOS版本，则在命令行执行yuminstall -y git即可完成安装。</li><li>Mac系统自带Git，不过默认没有安装，你需要运行xcode，然后选择菜单“xcode”-&gt;“Preferences”，选择“Downloads”这个Tab页面，再选择“Command Line Tools”，单击“Install”按钮即可完成安装。</li></ul><h3 id="3-2-2-配置"><a href="#3-2-2-配置" class="headerlink" title="3.2.2　配置"></a>3.2.2　配置</h3><p>​ 最后，我们通过在命令行依次输入以下命令来配置你的名字和邮箱，这样在提交代码的时候就能知道作者的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;Your Name&quot;<br>git config --global user.email &quot;email@example.com&quot;<br></code></pre></td></tr></table></figure><h2 id="3-3-IntelliJ-IDEA"><a href="#3-3-IntelliJ-IDEA" class="headerlink" title="3.3　IntelliJ IDEA"></a>3.3　IntelliJ IDEA</h2><p>​ 本书使用IntelliJ IDEA作为集成开发环境。当然，如果你非常熟悉Eclipse，也可以使用Eclipse。对于想入门学习IntelliJ IDEA的读者，笔者之前录制的一个免费视频可以奉献给大家，请通过“读者服务”扫码获取，详细的安装过程和介绍，该视频里均有。<br>​ 接下来我们看一下如何使用本书的代码。<br>​ 首先，我们通过下图所示的步骤将代码仓库导入本地。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600503653072.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600503771114.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p>​ 代码复制到本地之后，在IntelliJ IDEA右下角切换相应的分支，即可找到每一节对应的完整代码，如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600503891596.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600503970388.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166005040421910.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p>​ 由于在代码里，笔者使用了lombok自动生成getter、setter及构造函数，需要在IntelliJ IDEA中安装插件，否则代码会报红，具体安装可以参考下图所示的步骤。<br>​ 首先调出配置。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166005041853312.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p>​ 然后找到IDEA插件相关的配置。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166005042955714.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p>​ 接着在弹出来的窗口中输入lombok。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166005045025516.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p>​ 最后单击“Install”按钮安装，之后重启IntelliJ IDEA即可。</p><h1 id="第-4-章-服务端启动流程"><a href="#第-4-章-服务端启动流程" class="headerlink" title="第 4 章 服务端启动流程"></a>第 4 章 服务端启动流程</h1><p>​ 这一章，我们学习如何使用Netty来启动一个服务端应用程序。</p><h2 id="4-1-服务端启动最小化代码"><a href="#4-1-服务端启动最小化代码" class="headerlink" title="4.1　服务端启动最小化代码"></a>4.1　服务端启动最小化代码</h2><p>​ 以下是服务端启动的一个非常精简的Demo。</p><p>​ <strong>NettyServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>        serverBootstrap<br>                .group(bossGroup, workerGroup)<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>                    &#125;<br>                &#125;);<br>        serverBootstrap.bind(<span class="hljs-number">8000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上述代码首先创建了两个NioEventLoopGroup，这两个对象可以看作传统IO编程模型的两大线程组，bossGroup表示监听端口，接收新连接的线程组；workerGroup表示处理每一个连接的数据读写的线程组。用生活中的例子来讲就是，一个工厂要运作，必然要有一个老板负责从外面接活，然后有很多员工，负责具体干活。老板就是bossGroup，员工们就是workerGroup，bossGroup接收完连接，交给workerGroup去处理。</li><li>其次创建了一个引导类ServerBootstrap，这个类将引导服务端的启动工作。</li><li>通过.group(bossGroup,workerGroup)给引导类配置两大线程组，这个引导类的线程模型也就定型了。</li><li>然后指定服务端的IO模型为NIO，上述代码通过.channel(NioServerSocketChannel.class)来指定IO模型，也可以有其他选择。如果你想指定IO模型为BIO，那么这里配置上OioServerSocketChannel.class类型即可。当然通常我们也不会这么做，因为Netty的优势就在于NIO。</li><li>接着调用childHandler()方法，给这个引导类创建一个ChannelInitializer，主要是定义后续每个连接的数据读写，对于业务处理逻辑，不理解也没关系，后面我们会详细分析。在ChannelInitializer这个类中，有一个泛型参数NioSocketChannel，这个类就是Netty对NIO类型连接的抽象，而前面的NioServerSocketChannel也是对NIO类型连接的抽象，NioServerSocketChannel和NioSocketChannel的概念可以与BIO编程模型中的ServerSocket和Socket两个概念对应。</li></ul><p>最小化参数配置到这里就完成了，总结一下就是，要启动一个Netty服务端，必须要指定三类属性，分别是线程模型、IO模型、连接读写处理逻辑。有了这三者，之后再调用bind(8000)，就可以在本地绑定一个8000端口启动服务端。以上这段代码，读者可以直接复制到自己的IDE中运行。</p><h2 id="4-2-自动绑定递增端口"><a href="#4-2-自动绑定递增端口" class="headerlink" title="4.2　自动绑定递增端口"></a>4.2　自动绑定递增端口</h2><p>上面代码绑定了8000端口，接下来我们实现一个稍微复杂点的逻辑。我们指定一个起始端口号，比如1000；然后从1000端口往上找一个端口，直到这个端口能够绑定成功。比如1000端口不可用，我们就尝试绑定1001端口，然后1002端口，以此类推。</p><p>serverBootstrap.bind(8000)方法是一个异步方法，调用之后是立即返回的，它的返回值是一个ChannelFuture。我们可以给这个ChannelFuture添加一个监听器GenericFutureListener，然后在GenericFutureListener的operationComplete方法里，监听端口是否绑定成功。下面是监听端口是否绑定成功的代码片段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap.bind(<span class="hljs-number">8000</span>).addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="hljs-built_in">super</span> Void&gt;&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-built_in">super</span> Void&gt; future)</span> &#123;<br>        <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;端口绑定成功！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            System.err.println(<span class="hljs-string">&quot;端口绑定失败！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>接下来就可以从1000端口开始，往上找端口号，直到端口绑定成功。我们要做的就是在if (future.isSuccess())的else逻辑里重新绑定一个递增的端口。我们从这段绑定逻辑中抽取出一个bind方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ServerBootstrap serverBootstrap, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> port)</span> &#123;<br>    serverBootstrap.bind(port).addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="hljs-built_in">super</span> Void&gt;&gt;() &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-built_in">super</span> Void&gt; future)</span> &#123;<br>            <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;端口[&quot;</span> + port + <span class="hljs-string">&quot;]绑定成功！&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.err.println(<span class="hljs-string">&quot;端口[&quot;</span> + port + <span class="hljs-string">&quot;]绑定失败！&quot;</span>);<br>                bind(serverBootstrap, port + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中最关键的就是在端口绑定失败之后，重新调用自身方法，并且把端口号加一，这样，在我们的主流程里面就可以直接调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">bind(serverBootstrap, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>读者可以自行修改代码，运行之后看到效果，最终会发现，端口成功绑定在了1024。从1000开始到1023，端口均绑定失败，这是因为在笔者的Mac系统下，1023以下的端口号都被系统保留了，需要ROOT权限才能绑定。</p><p>以上就是自动绑定递增端口的逻辑。</p><p><strong>问题</strong>：服务端启动引导类ServerBootstrap除了指定线程模型、IO模型、连接读写处理逻辑，还可以做哪些事情？</p><h2 id="4-3-服务端启动的其他方法"><a href="#4-3-服务端启动的其他方法" class="headerlink" title="4.3　服务端启动的其他方法"></a>4.3　服务端启动的其他方法</h2><h3 id="4-3-1-handler-方法"><a href="#4-3-1-handler-方法" class="headerlink" title="4.3.1　handler()方法"></a>4.3.1　handler()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioServerSocketChannel&gt;() &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioServerSocketChannel ch)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端启动中&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>handler()方法可以和前面分析的childHandler()方法对应起来：childHandler()方法用于指定处理新连接数据的读写处理逻辑；handler()方法用于指定在服务端启动过程中的一些逻辑，通常情况下用不到这个方法。</p><h3 id="4-3-2-attr-方法"><a href="#4-3-2-attr-方法" class="headerlink" title="4.3.2　attr()方法"></a>4.3.2　attr()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap.attr(AttributeKey.newInstance(<span class="hljs-string">&quot;serverName&quot;</span>), <span class="hljs-string">&quot;nettyServer&quot;</span>)<br></code></pre></td></tr></table></figure><p>attr()方法可以给服务端Channel，也就是NioServerSocketChannel指定一些自定义属性，然后通过channel.attr()取出这个属性。比如，上面的代码可以指定服务端Channel的serverName属性，属性值为nettyServer，其实就是给NioServerSocketChannel维护一个Map而已，通常情况下也用不上这个方法。</p><h3 id="4-3-3-childAttr-方法"><a href="#4-3-3-childAttr-方法" class="headerlink" title="4.3.3　childAttr()方法"></a>4.3.3　childAttr()方法</h3><p>除了可以给服务端Channel即NioServerSocketChannel指定一些自定义属性，我们还可以给每一个连接都指定自定义属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap.childAttr(AttributeKey.newInstance(<span class="hljs-string">&quot;clientKey&quot;</span>), <span class="hljs-string">&quot;clientValue&quot;</span>)<br></code></pre></td></tr></table></figure><p>上面的childAttr()方法可以给每一个连接都指定自定义属性，后续我们可以通过channel.attr()方法取出该属性。</p><h3 id="4-3-4-option-方法"><a href="#4-3-4-option-方法" class="headerlink" title="4.3.4　option()方法"></a>4.3.4　option()方法</h3><p>option()方法可以给服务端Channel设置一些TCP参数，最常见的就是so_backlog，设置如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap.option(ChannelOption.SO_BACKLOG, <span class="hljs-number">1024</span>)<br></code></pre></td></tr></table></figure><p>这个设置表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁，服务器处理创建新连接较慢，则可以适当调大这个参数。</p><h3 id="4-3-5-childOption-方法"><a href="#4-3-5-childOption-方法" class="headerlink" title="4.3.5　childOption()方法"></a>4.3.5　childOption()方法</h3><p>childOption()方法可以给每个连接都设置一些TCP参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap<br>    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>    .childOption(ChannelOption.TCP_NODELAY, <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>上述代码中设置了两种TCP参数，其中：</p><ul><li>ChannelOption.SO_KEEPALIVE表示是否开启TCP底层心跳机制，true表示开启。</li><li>ChannelOption.TCP_NODELAY表示是否开启Nagle算法，true表示关闭，false表示开启。通俗地说，如果要求高实时性，有数据发送时就马上发送，就设置为关闭；如果需要减少发送次数，减少网络交互，就设置为开启。</li></ul><p>其他参数这里就不一一讲解了，读者有兴趣可以自行研究。</p><h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4　总结"></a>4.4　总结</h2><ul><li>在本章中，我们首先学习了Netty服务端启动的流程，一句话总结就是：首先创建一个引导类，然后给它指定线程模型、IO模型、连接读写处理逻辑，绑定端口之后，服务端就启动起来了。</li><li>然后我们学习到bind方法是异步的，可以通过这个异步机制来实现递增端口绑定。</li><li>最后我们讨论了Netty服务端启动的其他方法，主要包括给服务端Channel或者客户端Channel设置属性值、设置底层TCP参数。</li></ul><p>如果你觉得这个过程比较简单，想深入了解服务端启动的底层原理，可参考第21章。</p><h1 id="第-5-章-客户端启动流程"><a href="#第-5-章-客户端启动流程" class="headerlink" title="第 5 章 客户端启动流程"></a>第 5 章 客户端启动流程</h1><p>上一章，我们已经学习了Netty服务端启动流程；这一章，我们来学习Netty客户端启动流程。</p><h2 id="5-1-客户端启动Demo"><a href="#5-1-客户端启动Demo" class="headerlink" title="5.1　客户端启动Demo"></a>5.1　客户端启动Demo</h2><p>对于客户端的启动来说，和服务端的启动类似，依然需要线程模型、IO模型，以及IO业务处理逻辑三大参数。下面我们来看一下客户端启动的标准流程。</p><p><strong>NettyClient.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br>    <span class="hljs-keyword">public</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>        bootstrap<br>                <span class="hljs-comment">// 1.指定线程模型                </span><br>                .group(workerGroup)<br>                <span class="hljs-comment">// 2.指定 IO 类型为 NIO                </span><br>                .channel(NioSocketChannel.class)<br>                <span class="hljs-comment">// 3.IO 处理逻辑                </span><br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-comment">// 4.建立连接        </span><br>        bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">80</span>).addListener(future -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;连接成功！&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.err.println(<span class="hljs-string">&quot;连接失败！&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从上面的代码可以看到，客户端启动的引导类是Bootstrap，负责启动客户端和连接服务端；而在服务端启动的时候，这个引导类是ServerBootstrap。引导类创建完成之后，客户端启动的流程如下。</p><ul><li>与服务端的启动一样，需要给它指定线程模型，驱动连接的数据读写，这个线程的概念可以和第1章中IOClient.java创建的线程联系起来。</li><li>指定IO模型为NioSocketChannel，表示IO模型为NIO。当然，你可以设置IO模型为OioSocketChannel，但是通常不会这么做，因为Netty的优势在于NIO。</li><li>给引导类指定一个Handler，主要定义连接的业务处理逻辑，不理解没关系，在后面会详细分析。</li><li>配置完线程模型、IO模型、业务处理逻辑之后，调用connect方法进行连接，可以看到connect方法有两个参数，第一个参数可以填写IP或者域名，第二个参数填写端口号。由于connect方法返回的是一个Future，也就是说这个方法是异步的，通过addListener方法可以监听连接是否成功，进而打印连接信息。</li></ul><p>到了这里，一个客户端启动的Demo就完成了，其实只要和客户端Socket编程模型对应起来，这里的三个概念就会显得非常简单。读者如果忘掉了，可以先回顾一下第1章的IOClient.java，再来看这里的启动流程。</p><h2 id="5-2-失败重连"><a href="#5-2-失败重连" class="headerlink" title="5.2　失败重连"></a>5.2　失败重连</h2><p>在网络情况差的情况下，客户端第一次连接可能会连接失败，这个时候我们可能会尝试重连。重连的逻辑写在连接失败的逻辑块里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap<br>    .connect(<span class="hljs-string">&quot;meituan.com&quot;</span>, <span class="hljs-number">80</span>)<br>    .addListener(future -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;连接成功！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.err.println(<span class="hljs-string">&quot;连接失败！&quot;</span>);<br>            <span class="hljs-comment">// 重连  </span><br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>在重连的时候，依然调用同样的逻辑。因此，我们把建立连接的逻辑先抽取出来，然后在重连的时候，递归调用自身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(Bootstrap bootstrap, String host, <span class="hljs-type">int</span> port)</span> &#123;<br>    bootstrap.connect(host, port).addListener(future -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;连接成功！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.err.println(<span class="hljs-string">&quot;连接失败,开始重连&quot;</span>);<br>            connect(bootstrap, host, port);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这一段便是带有自动重连功能的逻辑，可以看到在连接失败的时候，会调用自身进行重连。</p><p>但是，在通常情况下，连接失败不会立即重连，而是通过一个指数退避的方式，比如每隔1秒、2秒、4秒、8秒，以2的幂次来建立连接，到达一定次数之后就放弃连接。接下来我们实现这段逻辑，默认重试5次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">connect(bootstrap, <span class="hljs-string">&quot;meituan.com&quot;</span>, <span class="hljs-number">80</span>, MAX_RETRY);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(Bootstrap bootstrap, String host, <span class="hljs-type">int</span> port, <span class="hljs-type">int</span> retry)</span> &#123;<br>        bootstrap.connect(host, port).addListener(future -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;连接成功！&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retry == <span class="hljs-number">0</span>) &#123;<br>                System.err.println(<span class="hljs-string">&quot;重试次数已用完,放弃连接！&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 第几次重连</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> (MAX_RETRY - retry) + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 本次重连的间隔</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; order;<br>                System.err.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;： 连接失败,第&quot;</span> + order + <span class="hljs-string">&quot;次重连……&quot;</span>);<br>                bootstrap.config().group().schedule(() -&gt; connect(bootstrap, host, port, retry--), delay, TimeUnit.SECONDS);<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看到，通过判断连接是否成功及剩余的重试次数，分别执行不同的逻辑。</p><ul><li>如果连接成功，则打印连接成功的消息。</li><li>如果连接失败但重试次数已经用完，则放弃连接。</li><li>如果连接失败但重试次数仍然没有用完，则计算下一次重连间隔delay，然后定期重连。</li></ul><p>在上面的代码中，我们看到，定时任务调用的是bootstrap.config().group().schedule()，其中bootstrap.config()这个方法返回的是BootstrapConfig，它是对Bootstrap配置参数的抽象，然后bootstrap.config().group()返回的就是我们在一开始配置的线程模型workerGroup，调用workerGroup的schedule方法即可实现定时任务逻辑。</p><p>在schedule方法块里，前四个参数原封不动地传递，最后一个重试次数参数减掉1，就是下一次建立连接时的上下文信息。读者可以自行修改代码，更改到一个连接不上的服务端Host或者Port，查看控制台日志就可以看到5次重连日志。</p><p>以上就是实现指数退避的客户端重连逻辑。</p><p><strong>问题</strong>：客户端启动过程中的引导类Bootstrap除了指定线程模型、IO模型、连接读写处理逻辑，还可以做哪些事情？</p><h2 id="5-3-客户端启动的其他方法"><a href="#5-3-客户端启动的其他方法" class="headerlink" title="5.3　客户端启动的其他方法"></a>5.3　客户端启动的其他方法</h2><h3 id="5-3-1-attr-方法"><a href="#5-3-1-attr-方法" class="headerlink" title="5.3.1　attr()方法"></a>5.3.1　attr()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap.attr(AttributeKey.newInstance(<span class="hljs-string">&quot;clientName&quot;</span>), <span class="hljs-string">&quot;nettyClient&quot;</span>)<br></code></pre></td></tr></table></figure><p>attr()方法可以为客户端Channel也就是NioSocketChannel绑定自定义属性，然后通过channel.attr()方法取出这个属性。比如，上面的代码可以指定客户端Channel的clientName属性，属性值为nettyClient，其实就是为NioSocketChannel维护一个Map而已。后续在NioSocketChannel通过参数传来传去的时候，就可以通过它来取出设置的属性，非常方便。</p><h3 id="5-3-2-option-方法"><a href="#5-3-2-option-方法" class="headerlink" title="5.3.2　option()方法"></a>5.3.2　option()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Bootstrap<br>    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>)<br>    .option(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>    .option(ChannelOption.TCP_NODELAY, <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>option()方法可以为连接设置一些TCP底层相关的属性，比如上面的代码中，我们设置了3种TCP属性，其中：</p><ul><li>ChannelOption.CONNECT_TIMEOUT_MILLIS表示连接的超时时间，超过这个时间，如果仍未连接到服务端，则表示连接失败。</li><li>ChannelOption.SO_KEEPALIVE表示是否开启TCP底层心跳机制，true表示开启。</li><li>ChannelOption.TCP_NODELAY表示是否开始Nagle算法，true表示关闭，false表示开启。通俗地说，如果要求高实时性，有数据发送时就马上发送，就设置为true；如果需要减少发送次数，减少网络交互，就设置为false。</li></ul><p>其他参数这里就不一一讲解了，读者有兴趣可以去自行研究。</p><h2 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4　总结"></a>5.4　总结</h2><ul><li>本章中我们首先学习了Netty客户端启动的流程，一句话总结就是：首先创建一个引导类，然后为它指定线程模型、IO模型、连接读写处理逻辑，连接上特定主机和端口后，客户端就启动起来了。</li><li>然后我们学习到connect方法是异步的，可以通过异步回调机制来实现指数退避重连逻辑。</li><li>最后我们讨论了Netty客户端启动的其他方法，主要包括给客户端Channel绑定自定义属性值、设置底层TCP参数。</li></ul><h2 id="5-5-思考"><a href="#5-5-思考" class="headerlink" title="5.5　思考"></a>5.5　思考</h2><p>与服务端启动相比，客户端启动的引导类少了哪些方法，为什么不需要这些方法？</p><h1 id="第-6-章-客户端与服务端双向通信"><a href="#第-6-章-客户端与服务端双向通信" class="headerlink" title="第 6 章 客户端与服务端双向通信"></a>第 6 章 客户端与服务端双向通信</h1><p>在前面两章中，我们学习了服务端启动与客户端启动的流程。熟悉了这两个流程之后，就可以建立服务端与客户端之间的连接了。本章我们用一个Demo来了解服务端和客户端是如何通信的。</p><p>本章要实现的功能是：在客户端连接成功之后，向服务端写一段数据；服务端收到数据之后打印，并向客户端返回一段数据。这里展示的是核心代码，完整代码请参考代码仓库对应的章节。</p><h2 id="6-1-客户端发送数据到服务端"><a href="#6-1-客户端发送数据到服务端" class="headerlink" title="6.1　客户端发送数据到服务端"></a>6.1　客户端发送数据到服务端</h2><p>在客户端启动流程这一章，读者已经了解到客户端相关的数据读写逻辑是通过Bootstrap的handler()方法指定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>        <span class="hljs-comment">// 指定连接数据读写逻辑</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>接下来在initChannel()方法里给客户端添加一个逻辑处理器，其作用是负责向服务端写数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;   <br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstClientHandler</span>());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>ch.pipeline()返回的是和这条连接相关的逻辑处理链，采用了责任链模式。</li><li>调用addLast()方法添加一个逻辑处理器，逻辑处理器的作用就是，在客户端建立连接成功之后，向服务端写数据。下面是这个逻辑处理器相关的代码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;： 客户端写出数据&quot;</span>);<br>        <span class="hljs-comment">// 1. 获取数据        </span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> getByteBuf(ctx);<br>        <span class="hljs-comment">// 2. 写数据        </span><br>        ctx.channel().writeAndFlush(buffer);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ByteBuf <span class="hljs-title function_">getByteBuf</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        <span class="hljs-comment">// 1. 获取二进制抽象 ByteBuf        </span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>        <span class="hljs-comment">// 2. 准备数据,指定字符串的字符集为 UTF-8        </span><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;你好,闪电侠！&quot;</span>.getBytes(StandardCharsets.UTF_8);<br>        <span class="hljs-comment">// 3. 填充数据到 ByteBuf        </span><br>        buffer.writeBytes(bytes);<br>        <span class="hljs-keyword">return</span> buffer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这个逻辑处理器继承自ChannelInboundHandlerAdapter，覆盖了channelActive()方法，这个方法会在客户端连接建立成功之后被调用。</p></li><li><p>客户端连接建立成功之后，调用channelActive()方法。在这个方法里，我们编写向服务端写数据的逻辑。</p></li><li><p>写数据的逻辑分为三步：首先需要获取一个Netty对二进制数据的抽象ByteBuf。在上面代码中，ctx.alloc()获取到一个ByteBuf的内存管理器，其作用就是分配一个ByteBuf。然后把字符串的二进制数据填充到ByteBuf，这样就获取到Netty需要的数据格式。最后调用ctx.channel().writeAndFlush()把数据写到服务端。</p></li></ul><p>以上就是客户端启动之后，向服务端写数据的逻辑。可以看到，和传统的Socket编程不同的是，Netty里的数据是以ByteBuf为单位的，所有需要写出的数据都必须放到一个ByteBuf中。数据的写出如此，数据的读取亦如此。接下来我们看一下服务端是如何读取这段数据的。</p><h2 id="6-2-服务端读取客户端数据"><a href="#6-2-服务端读取客户端数据" class="headerlink" title="6.2　服务端读取客户端数据"></a>6.2　服务端读取客户端数据</h2><p>在服务端启动流程这一章，我们提到，服务端相关的数据处理逻辑是通过ServerBootstrap的childHandler()方法指定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>        <span class="hljs-comment">// 指定连接数据读写逻辑    </span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>现在，我们在initChannel()方法里给服务端添加一个逻辑处理器，这个处理器的作用就是负责读取客户端发来的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstServerHandler</span>());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这个方法里的逻辑和客户端侧类似，获取服务端侧关于这个连接的逻辑处理链Pipeline，然后添加一个逻辑处理器，负责读取客户端发来的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;： 服务端读到数据 -&gt; &quot;</span> + byteBuf.toString(StandardCharsets.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端侧的逻辑处理器同样继承自ChannelInboundHandlerAdapter。与客户端不同的是，这里覆盖的方法是channelRead()，这个方法在接收到客户端发来的数据之后被回调。</p><p>这里的msg参数指的就是Netty里数据读写的载体，为什么这里不直接是ByteBuf，而需要强转一下呢？我们后面会分析到。这里我们强转之后，调用byteBuf.toString()就能够获得客户端发来的字符串数据。</p><p>我们先运行服务端，再运行客户端，下面两个图分别是服务端控制台和客户端控制台的输出。</p><p><strong>服务端</strong></p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166005225479918.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong>客户端</strong><br><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166005226725720.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p>到目前为止，我们已经实现了客户端发送数据和服务端打印，离本章开头提出的目标还差一半，接下来我们实现另外一半目标：服务端收到数据之后向客户端返回数据。</p><h2 id="6-3-服务端返回数据到客户端"><a href="#6-3-服务端返回数据到客户端" class="headerlink" title="6.3　服务端返回数据到客户端"></a>6.3　服务端返回数据到客户端</h2><p>服务端向客户端写数据逻辑与客户端的写数据逻辑一样，首先创建一个ByteBuf，然后填充二进制数据，最后调用writeAndFlush()方法写出去。下面是服务端返回数据的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>        <span class="hljs-comment">// 接收数据逻辑省略        </span><br>        <span class="hljs-comment">// 返回数据到客户端        </span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;： 服务端写出数据&quot;</span>);<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> getByteBuf(ctx);<br>        ctx.channel().writeAndFlush(out);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ByteBuf <span class="hljs-title function_">getByteBuf</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;你好,欢迎关注我的微信公众号,《闪电侠的博客》！&quot;</span>.getBytes(StandardCharsets.UTF_8);<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>        buffer.writeBytes(bytes);<br>        <span class="hljs-keyword">return</span> buffer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，轮到客户端了。客户端读取数据的逻辑和服务端读取数据的逻辑一样，同样是覆盖channelRead()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-comment">// 写数据相关的逻辑省略    </span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;： 客户端读到数据 -&gt; &quot;</span> + byteBuf.toString(StandardCharsets.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将这段逻辑添加到客户端的逻辑处理器FirstClientHandler之后，客户端就能收到服务端发来的数据。</p><p>客户端与服务端读写数据的逻辑完成之后，先运行服务端，再运行客户端，控制台输出分别如下面两图所示。</p><p><strong>服务端</strong></p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166005242956922.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong>客户端</strong></p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166005244145124.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p>到这里，本章要实现的客户端与服务端双向通信的功能就实现完毕了。</p><h2 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4　总结"></a>6.4　总结</h2><ul><li>首先，我们了解到客户端和服务端的逻辑处理均在启动的时候，通过为逻辑处理链Pipeline添加逻辑处理器，来编写数据的读写逻辑。Pipeline的逻辑我们在后面会分析。</li><li>然后，在客户端连接成功之后，会回调到逻辑处理器的channelActive()方法。不管服务端还是客户端，收到数据之后都会调用channelRead()方法。</li></ul><p>写数据调用writeAndFlush()方法，客户端与服务端交互的二进制数据载体为ByteBuf，ByteBuf通过连接的内存管理器创建，字节数据填充到ByteBuf之后才能写到对端。接下来一章我们会重点分析ByteBuf。</p><h2 id="6-5-思考"><a href="#6-5-思考" class="headerlink" title="6.5　思考"></a>6.5　思考</h2><p>如何实现在新连接接入的时候，服务端主动向客户端推送消息，客户端回复服务端消息？</p><h1 id="第-7-章-数据载体-ByteBuf-的介绍"><a href="#第-7-章-数据载体-ByteBuf-的介绍" class="headerlink" title="第 7 章 数据载体 ByteBuf 的介绍"></a>第 7 章 数据载体 ByteBuf 的介绍</h1><p>在前面的章节中，我们已经了解到，Netty的数据读写是以ByteBuf为单位进行交互的。本章我们就来详细剖析一下ByteBuf。</p><h2 id="7-1-ByteBuf的结构"><a href="#7-1-ByteBuf的结构" class="headerlink" title="7.1　ByteBuf的结构"></a>7.1　ByteBuf的结构</h2><p>首先，我们来了解一下ByteBuf的结构，如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166005254079426.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><p>从ByteBuf的结构图可以看到：</p><ul><li>ByteBuf是一个字节容器，容器里面的数据分为三部分，第一部分是已经丢弃的字节，这部分数据是无效的；第二部分是可读字节，这部分数据是ByteBuf的主体数据，从ByteBuf里读取的数据都来自这一部分；最后一部分的数据是可写字节，所有写到ByteBuf的数据都会写到这一段。后面的虚线部分表示该ByteBuf最多还能扩容多少容量。</li><li>以上三部分内容是被两个指针划分出来的，从左到右依次是读指针（readerIndex）和写指针（writerIndex）。还有一个变量capacity，表示ByteBuf底层内存的总容量。</li><li>从ByteBuf中每读取一字节，readerIndex自增1，ByteBuf里总共有writerIndex-readerIndex字节可读。由此可以知道，当readerIndex与writerIndex相等的时候，ByteBuf不可读。</li><li>写数据是从writerIndex指向的部分开始写的，每写一字节，writerIndex自增1，直到增到capacity。这个时候，表示ByteBuf已经不可写。</li><li>ByteBuf里其实还有一个参数maxCapacity。当向ByteBuf写数据的时候，如果容量不足，则可以进行扩容，直到capacity扩容到maxCapacity，超过maxCapacity就会报错。</li></ul><p>Netty使用ByteBuf这个数据结构可以有效地区分可读数据和可写数据，读写之间相互没有冲突。当然，ByteBuf只是对二进制数据的抽象，具体底层的实现我们后面会讲到。在这里，读者只需要知道Netty关于数据读写只认ByteBuf。下面我们来学习ByteBuf常用的API。</p><h2 id="7-2-容量API"><a href="#7-2-容量API" class="headerlink" title="7.2　容量API"></a>7.2　容量API</h2><p><strong>capacity()</strong><br> 表示ByteBuf底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式，后面我们介绍ByteBuf的分类时会讲到。<br><strong>maxCapacity()</strong><br> 表示ByteBuf底层最大能够占用多少字节的内存，当向ByteBuf中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到maxCapacity，超过这个数，就抛出异常。<br><strong>readableBytes()与isReadable()</strong><br> readableBytes()表示ByteBuf当前可读的字节数，它的值等于writerIndex-readerIndex，如果两者相等，则不可读，isReadable()方法返回false。<br><strong>writableBytes()、isWritable()与maxWritableBytes()</strong><br> writableBytes()表示ByteBuf当前可写的字节数，它的值等于capacity-writerIndex，如果两者相等，则表示不可写，isWritable()返回false，但是这个时候，并不代表不能往ByteBuf写数据了。如果发现往ByteBuf写数据写不进去，Netty会自动扩容ByteBuf，直到底层的内存大小为maxCapacity，而maxWritableBytes()就表示可写的最大字节数，它的值等于maxCapacitywriterIndex。</p><h2 id="7-3-读写指针相关的API"><a href="#7-3-读写指针相关的API" class="headerlink" title="7.3　读写指针相关的API"></a>7.3　读写指针相关的API</h2><p><strong>readerIndex()与readerIndex(int)</strong><br>前者表示返回当前的读指针readerIndex，后者表示设置读指针。<br><strong>writeIndex()与writeIndex(int)</strong><br>前者表示返回当前的写指针writerIndex，后者表示设置写指针。<br><strong>markReaderIndex()与resetReaderIndex()</strong><br>前者表示把当前的读指针保存起来，后者表示把当前的读指针恢复到之前保存的值。下面两段代码是等价的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代码片段一</span><br><span class="hljs-type">int</span> <span class="hljs-variable">readerIndex</span> <span class="hljs-operator">=</span> buffer.readerIndex();<br><span class="hljs-comment">// 其他操作</span><br>buffer.readerIndex(readerIndex);<br><br><span class="hljs-comment">// 代码片段二</span><br>buffer.markReaderIndex();<br><span class="hljs-comment">// 其他操作</span><br>buffer.resetReaderIndex();<br></code></pre></td></tr></table></figure><p>希望大家多使用代码片段二这种方式，不需要自己定义变量。无论Buffer被当作参数传递到哪里，调用resetReaderIndex()都可以恢复到之前的状态，在解析自定义协议的数据包时非常常见，推荐大家使用这一对API。<br><strong>markWriterIndex()与resetWriterIndex()</strong><br>这一对API的作用与上一对API类似，这里不再赘述。</p><h2 id="7-4-读写API"><a href="#7-4-读写API" class="headerlink" title="7.4　读写API"></a>7.4　读写API</h2><p>本质上，关于ByteBuf的读写都可以看作从指针开始的地方开始读写数据。</p><p><strong>writeBytes(byte[] src)与buffer.readBytes(byte[] dst)</strong><br>writeBytes()表示把字节数组src里的数据全部写到ByteBuf，而readBytes()表示把ByteBuf里的数据全部读取到dst。这里dst字节数组的大小通常等于readableBytes()，而src字节数组大小的长度通常小于等于writableBytes()。</p><p><strong>writeByte(byte b)与buffer.readByte()</strong><br>writeByte()表示往ByteBuf中写一字节，而buffer.readByte()表示从ByteBuf中读取一字节，类似的API还有writeBoolean()、writeChar()、writeShort()、writeInt()、writeLong()、writeFloat()、writeDouble()，以及readBoolean()、readChar()、readShort()、readInt()、readLong()、readFloat()、readDouble()，这里不再赘述，相信读者应该很容易理解这些API。</p><p>与读写API类似的API还有getBytes()、getByte()与setBytes()、setByte()系列，唯一的区别就是get、set不会改变读写指针，而read、write会改变读写指针，这一点在解析数据的时候千万要注意。<br><strong>release()与retain()</strong><br>由于Netty使用了堆外内存，而堆外内存是不被JVM直接管理的。也就是说，申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。这有点类似于C语言里，申请到的内存必须手工释放，否则会造成内存泄漏。</p><p>Netty的ByteBuf是通过引用计数的方式管理的，如果一个ByteBuf没有地方被引用到，则需要回收底层内存。在默认情况下，当创建完一个ByteBuf时，它的引用为1，然后每次调用retain()方法，它的引用就加一，release()方法的原理是将引用计数减一，减完之后如果发现引用计数为0，则直接回收ByteBuf底层的内存。</p><p><strong>slice()、duplicate()、copy()</strong><br>在通常情况下，这三个方法会被放到一起比较，三者的返回值分别是一个新的ByteBuf对象。</p><ul><li>slice()方法从原始ByteBuf中截取一段，这段数据是从readerIndex到writeIndex的，同时，返回的新的ByteBuf的最大容量maxCapacity为原始ByteBuf的readableBytes()。</li><li>duplicate()方法把整个ByteBuf都截取出来，包括所有的数据、指针信息。</li><li>slice()方法与duplicate()方法的相同点是：底层内存及引用计数与原始ByteBuf共享，也就是说，经过slice()方法或者duplicate()方法返回的ByteBuf调用write系列方法都会影响到原始ByteBuf，但是它们都维持着与原始ByteBuf相同的内存引用计数和不同的读写指针。</li><li>slice()方法与duplicate()方法的不同点就是：slice()方法只截取从readerIndex到writerIndex之间的数据，它返回的ByteBuf的最大容量被限制到原始ByteBuf的readableBytes()，而duplicate()方法是把整个ByteBuf都与原始ByteBuf共享。</li><li>slice()方法与duplicate()方法不会复制数据，它们只是通过改变读写指针来改变读写的行为，而最后一个方法copy()会直接从原始ByteBuf中复制所有的信息，包括读写指针及底层对应的数据，因此，往copy()方法返回的ByteBuf中写数据不会影响原始ByteBuf。</li><li>slice()方法和duplicate()方法不会改变ByteBuf的引用计数，所以原始ByteBuf调用release()方法之后发现引用计数为零，就开始释放内存，调用这两个方法返回的ByteBuf也会被释放。这时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次retain()方法来增加引用，表示它们对应的底层内存多了一次引用，引用计数为2。在释放内存的时候，需要调用两次release()方法，将引用计数降到零，才会释放内存。</li><li>这三个方法均维护着自己的读写指针，与原始ByteBuf的读写指针无关，相互之间不受影响。</li></ul><p><strong>retainedSlice()与retainedDuplicate()</strong><br>相信读者应该已经猜到这两个API的作用了，它们的作用是在截取内存片段的同时，增加内存的引用计数，分别与下面两段代码等价。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// retainedSlice 等价于</span><br>slice().retain();<br><span class="hljs-comment">// retainedDuplicate() 等价于</span><br>duplicate().retain();<br></code></pre></td></tr></table></figure><p>使用slice()和duplicate()方法的时候，千万要理清内存共享、引用计数共享、读写指针不共享等概念。下面举两个常见的容易出错的例子。<br><strong>例1：多次释放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Buffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> xxx;<br>doWith(buffer);<br><span class="hljs-comment">// 一次释放</span><br>buffer.release();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWith</span> <span class="hljs-params">(Bytebuf buffer)</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 没有增加引用计数</span><br>    <span class="hljs-type">Buffer</span> <span class="hljs-variable">slice</span> <span class="hljs-operator">=</span> buffer.slice();<br>    foo(slice);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span> <span class="hljs-params">(ByteBuf buffer)</span>&#123;<br>    <span class="hljs-comment">// 从缓冲区读取并处理    </span><br>    <span class="hljs-comment">// 重复释放   </span><br>    buffer.release();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的doWith有时候是用户自定义的方法，有时候是Netty的回调方法，如channelRead()等。</p><p><strong>例2：不释放造成内存泄漏</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Buffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> xxx;<br>doWith(buffer);<br><span class="hljs-comment">// 引用计数为2,调用release()方法之后,引用计数为1,无法释放内存</span><br>buffer.release();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWith</span><span class="hljs-params">(Bytebuf buffer)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 增加引用计数</span><br>    <span class="hljs-type">Buffer</span> <span class="hljs-variable">slice</span> <span class="hljs-operator">=</span> buffer.retainedSlice();<br>    foo(slice);<br>    <span class="hljs-comment">// 没有调用release()方法</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(ByteBuf buffer)</span> &#123;<br>    <span class="hljs-comment">//从缓冲区读取并处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>想要避免以上两种情况的发生，大家只需要记住一点，在一个函数体里面，只要增加了引用计数（包括ByteBuf的创建和手动调用retain()方法），就必须调用release()方法。</p><h2 id="7-5-实战"><a href="#7-5-实战" class="headerlink" title="7.5　实战"></a>7.5　实战</h2><p>了解了以上API之后，我们使用上述API来写一个简单的Demo。</p><p><strong>ByteBufTest.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBufAllocator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">9</span>, <span class="hljs-number">100</span>);<br>        print(<span class="hljs-string">&quot;allocate ByteBuf(9, 100)&quot;</span>, buffer);<br>        <span class="hljs-comment">// write方法改变写指针,写完之后写指针未到capacity的时候,buffer仍然可写</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        print(<span class="hljs-string">&quot;writeBytes(1,2,3,4)&quot;</span>, buffer);<br>        <span class="hljs-comment">// write方法改变写指针,写完之后写指针未到capacity的时候,buffer仍然可写,写完int类型之后,写指针增加4</span><br>        buffer.writeInt(<span class="hljs-number">12</span>);<br>        print(<span class="hljs-string">&quot;writeInt(12)&quot;</span>, buffer);<br>        <span class="hljs-comment">// write方法改变写指针,写完之后写指针等于capacity的时候,buffer不可写</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">5</span>&#125;);<br>        print(<span class="hljs-string">&quot;writeBytes(5)&quot;</span>, buffer);<br>        <span class="hljs-comment">// write方法改变写指针,写的时候发现buffer不可写则开始扩容,扩容之后capacity随即改变</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">6</span>&#125;);<br>        print(<span class="hljs-string">&quot;writeBytes(6)&quot;</span>, buffer);<br>        <span class="hljs-comment">// get方法不改变读写指针</span><br>        System.out.println(<span class="hljs-string">&quot;getByte(3) return： &quot;</span> + buffer.getByte(<span class="hljs-number">3</span>));<br>        System.out.println(<span class="hljs-string">&quot;getShort(3) return： &quot;</span> + buffer.getShort(<span class="hljs-number">3</span>));<br>        System.out.println(<span class="hljs-string">&quot;getInt(3) return： &quot;</span> + buffer.getInt(<span class="hljs-number">3</span>));<br>        print(<span class="hljs-string">&quot;getByte()&quot;</span>, buffer);<br>        <span class="hljs-comment">// set方法不改变读写指针</span><br>        buffer.setByte(buffer.readableBytes() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        print(<span class="hljs-string">&quot;setByte()&quot;</span>, buffer);<br>        <span class="hljs-comment">// read方法改变读指针</span><br>        <span class="hljs-type">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[buffer.readableBytes()];<br>        buffer.readBytes(dst);<br>        print(<span class="hljs-string">&quot;readBytes(&quot;</span> + dst.length + <span class="hljs-string">&quot;)&quot;</span>, buffer);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String action, ByteBuf buffer)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;after ===========&quot;</span> + action + <span class="hljs-string">&quot;============&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;capacity()： &quot;</span> + buffer.capacity());<br>        System.out.println(<span class="hljs-string">&quot;maxCapacity()： &quot;</span> + buffer.maxCapacity());<br>        System.out.println(<span class="hljs-string">&quot;readerIndex()： &quot;</span> + buffer.readerIndex());<br>        System.out.println(<span class="hljs-string">&quot;readableBytes()： &quot;</span> + buffer.readableBytes());<br>        System.out.println(<span class="hljs-string">&quot;isReadable()： &quot;</span> + buffer.isReadable());<br>        System.out.println(<span class="hljs-string">&quot;writerIndex()： &quot;</span> + buffer.writerIndex());<br>        System.out.println(<span class="hljs-string">&quot;writableBytes()： &quot;</span> + buffer.writableBytes());<br>        System.out.println(<span class="hljs-string">&quot;isWritable()： &quot;</span> + buffer.isWritable());<br>        System.out.println(<span class="hljs-string">&quot;maxWritableBytes()： &quot;</span> + buffer.maxWritableBytes());<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出如下:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">after ===========allocate <span class="hljs-constructor">ByteBuf(9, 100)</span>============<br>capacity<span class="hljs-literal">()</span>： <span class="hljs-number">9</span><br>max<span class="hljs-constructor">Capacity()</span>： <span class="hljs-number">100</span><br>reader<span class="hljs-constructor">Index()</span>： <span class="hljs-number">0</span><br>readable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">0</span><br>is<span class="hljs-constructor">Readable()</span>： <span class="hljs-literal">false</span><br>writer<span class="hljs-constructor">Index()</span>： <span class="hljs-number">0</span><br>writable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">9</span><br>is<span class="hljs-constructor">Writable()</span>： <span class="hljs-literal">true</span><br>max<span class="hljs-constructor">WritableBytes()</span>： <span class="hljs-number">100</span><br><br>after ===========write<span class="hljs-constructor">Bytes(1,2,3,4)</span>============<br>capacity<span class="hljs-literal">()</span>： <span class="hljs-number">9</span><br>max<span class="hljs-constructor">Capacity()</span>： <span class="hljs-number">100</span><br>reader<span class="hljs-constructor">Index()</span>： <span class="hljs-number">0</span><br>readable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">4</span><br>is<span class="hljs-constructor">Readable()</span>： <span class="hljs-literal">true</span><br>writer<span class="hljs-constructor">Index()</span>： <span class="hljs-number">4</span><br>writable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">5</span><br>is<span class="hljs-constructor">Writable()</span>： <span class="hljs-literal">true</span><br>max<span class="hljs-constructor">WritableBytes()</span>： <span class="hljs-number">96</span><br><br>after ===========write<span class="hljs-constructor">Int(12)</span>============<br>capacity<span class="hljs-literal">()</span>： <span class="hljs-number">9</span><br>max<span class="hljs-constructor">Capacity()</span>： <span class="hljs-number">100</span><br>reader<span class="hljs-constructor">Index()</span>： <span class="hljs-number">0</span><br>readable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">8</span><br>is<span class="hljs-constructor">Readable()</span>： <span class="hljs-literal">true</span><br>writer<span class="hljs-constructor">Index()</span>： <span class="hljs-number">8</span><br>writable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">1</span><br>is<span class="hljs-constructor">Writable()</span>： <span class="hljs-literal">true</span><br>max<span class="hljs-constructor">WritableBytes()</span>： <span class="hljs-number">92</span><br><br>after ===========write<span class="hljs-constructor">Bytes(5)</span>============<br>capacity<span class="hljs-literal">()</span>： <span class="hljs-number">9</span><br>max<span class="hljs-constructor">Capacity()</span>： <span class="hljs-number">100</span><br>reader<span class="hljs-constructor">Index()</span>： <span class="hljs-number">0</span><br>readable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">9</span><br>is<span class="hljs-constructor">Readable()</span>： <span class="hljs-literal">true</span><br>writer<span class="hljs-constructor">Index()</span>： <span class="hljs-number">9</span><br>writable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">0</span><br>is<span class="hljs-constructor">Writable()</span>： <span class="hljs-literal">false</span><br>max<span class="hljs-constructor">WritableBytes()</span>： <span class="hljs-number">91</span><br><br>after ===========write<span class="hljs-constructor">Bytes(6)</span>============<br>capacity<span class="hljs-literal">()</span>： <span class="hljs-number">64</span><br>max<span class="hljs-constructor">Capacity()</span>： <span class="hljs-number">100</span><br>reader<span class="hljs-constructor">Index()</span>： <span class="hljs-number">0</span><br>readable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">10</span><br>is<span class="hljs-constructor">Readable()</span>： <span class="hljs-literal">true</span><br>writer<span class="hljs-constructor">Index()</span>： <span class="hljs-number">10</span><br>writable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">54</span><br>is<span class="hljs-constructor">Writable()</span>： <span class="hljs-literal">true</span><br>max<span class="hljs-constructor">WritableBytes()</span>： <span class="hljs-number">90</span><br><br>get<span class="hljs-constructor">Byte(3)</span> return： <span class="hljs-number">4</span><br>get<span class="hljs-constructor">Short(3)</span> return： <span class="hljs-number">1024</span><br>get<span class="hljs-constructor">Int(3)</span> return： <span class="hljs-number">67108864</span><br>after ===========get<span class="hljs-constructor">Byte()</span>============<br>capacity<span class="hljs-literal">()</span>： <span class="hljs-number">64</span><br>max<span class="hljs-constructor">Capacity()</span>： <span class="hljs-number">100</span><br>reader<span class="hljs-constructor">Index()</span>： <span class="hljs-number">0</span><br>readable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">10</span><br>is<span class="hljs-constructor">Readable()</span>： <span class="hljs-literal">true</span><br>writer<span class="hljs-constructor">Index()</span>： <span class="hljs-number">10</span><br>writable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">54</span><br>is<span class="hljs-constructor">Writable()</span>： <span class="hljs-literal">true</span><br>max<span class="hljs-constructor">WritableBytes()</span>： <span class="hljs-number">90</span><br><br>after ===========set<span class="hljs-constructor">Byte()</span>============<br>capacity<span class="hljs-literal">()</span>： <span class="hljs-number">64</span><br>max<span class="hljs-constructor">Capacity()</span>： <span class="hljs-number">100</span><br>reader<span class="hljs-constructor">Index()</span>： <span class="hljs-number">0</span><br>readable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">10</span><br>is<span class="hljs-constructor">Readable()</span>： <span class="hljs-literal">true</span><br>writer<span class="hljs-constructor">Index()</span>： <span class="hljs-number">10</span><br>writable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">54</span><br>is<span class="hljs-constructor">Writable()</span>： <span class="hljs-literal">true</span><br>max<span class="hljs-constructor">WritableBytes()</span>： <span class="hljs-number">90</span><br><br>after ===========read<span class="hljs-constructor">Bytes(10)</span>============<br>capacity<span class="hljs-literal">()</span>： <span class="hljs-number">64</span><br>max<span class="hljs-constructor">Capacity()</span>： <span class="hljs-number">100</span><br>reader<span class="hljs-constructor">Index()</span>： <span class="hljs-number">10</span><br>readable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">0</span><br>is<span class="hljs-constructor">Readable()</span>： <span class="hljs-literal">false</span><br>writer<span class="hljs-constructor">Index()</span>： <span class="hljs-number">10</span><br>writable<span class="hljs-constructor">Bytes()</span>： <span class="hljs-number">54</span><br>is<span class="hljs-constructor">Writable()</span>： <span class="hljs-literal">true</span><br>max<span class="hljs-constructor">WritableBytes()</span>： <span class="hljs-number">90</span><br><br><br></code></pre></td></tr></table></figure><p>了解了ByteBuf的结构之后，不难理解控制台的输出。</p><h2 id="7-6-总结"><a href="#7-6-总结" class="headerlink" title="7.6　总结"></a>7.6　总结</h2><ul><li>本章我们分析了Netty对二进制数据的抽象ByteBuf的结构，本质上它的原理就是，引用了一段内存，这段内存可以是堆内的，也可以是堆外的，然后用引用计数来控制这段内存是否需要被释放。使用读写指针来控制ByteBuf的读写，可以理解为是外观模式的一种使用。</li><li>基于读写指针和容量、最大可扩容容量，衍生出一系列读写方法，要注意read、write与get、set的区别。</li><li>多个ByteBuf可以引用同一段内存，通过引用计数来控制内存的释放，遵循谁retain()谁release()的原则。</li><li>最后，我们通过一个具体的例子说明了ByteBuf的实际使用。</li></ul><h2 id="7-7-思考"><a href="#7-7-思考" class="headerlink" title="7.7　思考"></a>7.7　思考</h2><p>slice()方法可能用在什么场景？</p><h1 id="第-8-章-客户端与服务端通信协议编解码"><a href="#第-8-章-客户端与服务端通信协议编解码" class="headerlink" title="第 8 章 客户端与服务端通信协议编解码"></a>第 8 章 客户端与服务端通信协议编解码</h1><p>在学习了ByteBuf的API之后，本章我们来学习如何设计并实现客户端与服务端的通信协议。</p><h2 id="8-1-什么是客户端与服务端的通信协议"><a href="#8-1-什么是客户端与服务端的通信协议" class="headerlink" title="8.1　什么是客户端与服务端的通信协议"></a>8.1　什么是客户端与服务端的通信协议</h2><p>无论使用Netty还是使用原始的Socket编程，基于TCP通信的数据包格式均为二进制，协议指的就是客户端与服务端事先商量好的，每一个二进制数据包中的每一段字节分别代表什么含义的规则。一个简单的登录指令如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/909e0ec21694d4cf70d5cd8a866f375b.jpg" srcset="/img/loading.gif" lazyload alt="登录指令"></p><p>在这个数据包中，第一个字节为1表示这是一个登录指令，接下来是用户名和密码，这两个值以\0分割，客户端发送这段二进制数据包到服务端，服务端就能根据这个协议来取出用户名和密码，执行登录逻辑。在实际的通信协议设计中，我们会考虑更多细节，比这个协议稍微复杂一些。</p><p>那么，协议设计好之后，客户端与服务端的通信过程又是怎样的呢？</p><p>客户端与服务端的通信如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E9%80%9A%E4%BF%A1.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p><ul><li>客户端把一个Java对象按照通信协议转换成二进制数据包。</li><li>通过网络，把这段二进制数据包发送到服务端。在数据的传输过程中，由TCP&#x2F;IP协议负责数据的传输，与应用层无关。</li><li>服务端接收到数据之后，按照协议取出二进制数据包中的相应字段，包装成Java对象，交给应用逻辑处理。</li><li>服务端处理完之后，如果需要生成响应给客户端，则按照相同的流程进行。</li></ul><p>第1章已经列出了实现一个支持单聊和群聊的IM指令集合，设计协议的目的就是客户端与服务端能够识别这些具体的指令。接下来，我们就看一下如何设计这个通信协议。</p><h2 id="8-2-通信协议的设计"><a href="#8-2-通信协议的设计" class="headerlink" title="8.2　通信协议的设计"></a>8.2　通信协议的设计</h2><p>通信协议的设计如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1.jpg" srcset="/img/loading.gif" lazyload alt="通信协议的设计"></p><ul><li>第一个字段是魔数，通常情况下为固定的几字节（这里规定为4字节）。为什么需要这个字段，而且还是一个固定的数？假设我们在服务器上开了一个端口，比如80端口，如果没有这个魔数，任何数据包传递到服务器，服务器都会根据自定义协议来进行处理，包括不符合自定义协议规范的数据包。例如，直接通过http:&#x2F;&#x2F;服务器IP来访问服务器（默认为80端口），服务端收到的是一个标准的HTTP协议数据包，但是它仍然会按照事先约定好的协议来处理HTTP协议，显然，这是会解析出错的。而有了这个魔数之后，服务端首先取出前面4字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，出于安全考虑，可以直接关闭连接以节省资源。在Java字节码的二进制文件中，开头的4字节为0xcafebabe，用来标识这是一个字节码文件，亦有异曲同工之妙。</li><li>接下来的1字节为版本号，通常情况下是预留字段，在协议升级的时候用到，有点类似TCP协议中的一个字段标识是IPV4协议还是IPV6协议。在大多数情况下，这个字段是用不到的，但是为了协议能够支持升级，还是先留着。</li><li>第三部分的序列化算法表示如何把Java对象转换为二进制数据及二进制数据如何转换回Java对象，比如Java自带的序列化、JSON、Hessian等序列化方式。</li><li>第四部分的字段表示指令，关于指令相关的介绍，我们在前面已经讨论过。服务端或者客户端每收到一种指令，都会有相应的处理逻辑。这里我们用1字节来表示，最高支持256种指令，对于这个即时聊天系统来说已经完全足够了。</li><li>第五部分的字段表示数据长度，占4字节。</li><li>最后一部分为数据内容，每一种指令对应的数据都是不一样的，比如登录的时候需要用户名和密码，收消息的时候需要用户标识和具体消息内容等。</li></ul><p>在通常情况下，这样一套标准的协议能够适配大多数情况下的客户端与服务端的通信场景，接下来我们就看一下如何使用Netty来实现这套协议。</p><h2 id="8-3-通信协议的实现"><a href="#8-3-通信协议的实现" class="headerlink" title="8.3　通信协议的实现"></a>8.3　通信协议的实现</h2><p>我们把Java对象根据协议封装成二进制数据包的过程称为编码，把从二进制数据包中解析出Java对象的过程称为解码。在学习如何使用Netty进行通信协议的编解码之前，我们先来定义一下客户端与服务端通信的Java对象。</p><h3 id="8-3-1-Java对象"><a href="#8-3-1-Java对象" class="headerlink" title="8.3.1　Java对象"></a>8.3.1　Java对象</h3><p>如下代码定义通信过程中的Java对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Packet</span> &#123;<br>    <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * 协议版本     </span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Byte</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">/**    </span><br><span class="hljs-comment">	* 指令    </span><br><span class="hljs-comment">	*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Byte <span class="hljs-title function_">getCommand</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>以上是通信过程中Java对象的抽象类。可以看到，我们定义了一个版本号（默认值为1），以及一个获取指令的抽象方法。所有的指令数据包都必须实现这个方法，这样我们就可以知道某种指令的含义。</li><li>@Data注解由lombok提供，它会自动帮我们生产getter、setter方法，减少大量重复代码，推荐使用。</li></ul><p>接下来，以客户端登录请求为例，定义登录请求数据包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-type">Byte</span> <span class="hljs-variable">LOGIN_REQUEST</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginRequestPacket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Packet</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer userId;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Byte <span class="hljs-title function_">getCommand</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> LOGIN_REQUEST;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>登录请求数据包继承自Packet定义了3个字段，分别是用户ID、用户名和密码。其中最为重要的就是覆盖了父类的getCommand()方法，值为常量LOGIN_REQUEST。<br>Java对象定义完成之后，我们需要定义一种规则，如何把一个Java对象转换成二进制数据，这个规则叫作Java对象的序列化。</p><h3 id="8-3-2-序列化"><a href="#8-3-2-序列化" class="headerlink" title="8.3.2　序列化"></a>8.3.2　序列化</h3><p>如下代码定义序列化接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Serializer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化算法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">byte</span> <span class="hljs-title function_">getSerializerAlgorithm</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Java 对象转换成二进制数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">byte</span>[] serialize(Object object);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 二进制数据转换成Java对象</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-type">byte</span>[] bytes)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>序列化接口有3个方法：getSerializerAlgorithm()方法获取具体的序列化算法标识，serialize()方法将Java对象转换成字节数组，deserialize()方法将字节数组转换成某种类型的Java对象。在此，使用最简单的JSON序列化方式，将阿里巴巴的Fastjson作为序列化框架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SerializerAlgorithm</span> &#123;<br>    <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * JSON序列化标识     </span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">byte</span> <span class="hljs-variable">JSON</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JSONSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">getSerializerAlgorithm</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SerializerAlgorithm.JSON;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] serialize(Object object) &#123;<br>        <span class="hljs-keyword">return</span> JSON.toJSONBytes(object);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-type">byte</span>[] bytes)</span> &#123;<br>        <span class="hljs-keyword">return</span> JSON.parseObject(bytes, clazz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们定义一下序列化算法的类型，以及默认序列化算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Serializer</span> &#123;<br>	<span class="hljs-comment">/**     </span><br><span class="hljs-comment">	* JSON序列化     </span><br><span class="hljs-comment">	*/</span><br>    <span class="hljs-type">byte</span> <span class="hljs-variable">JSON_SERIALIZER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-type">Serializer</span> <span class="hljs-variable">DEFAULT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONSerializer</span>();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就实现了序列化相关的逻辑。如果想要实现其他序列化算法，则只需要继承Serializer，然后定义序列化算法的标识，再覆盖两个方法即可。<br>序列化定义了Java对象与二进制数据的互转过程。接下来，我们学习如何把这部分数据编码到通信协议的二进制数据包中去。</p><h3 id="8-3-3-编码：封装成二进制数据的过程"><a href="#8-3-3-编码：封装成二进制数据的过程" class="headerlink" title="8.3.3　编码：封装成二进制数据的过程"></a>8.3.3　编码：封装成二进制数据的过程</h3><p><strong>PacketCodeC.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAGIC_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x12345678</span>;<br><span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">encode</span><span class="hljs-params">(Packet packet)</span> &#123;<br>    <span class="hljs-comment">// 1. 创建 ByteBuf 对象</span><br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.ioBuffer();<br>    <span class="hljs-comment">// 2. 序列化 Java 对象</span><br>    <span class="hljs-type">byte</span>[] bytes = Serializer.DEFAULT.serialize(packet);<br>    <span class="hljs-comment">// 3. 实际编码过程</span><br>    byteBuf.writeInt(MAGIC_NUMBER);<br>    byteBuf.writeByte(packet.getVersion());<br>    byteBuf.writeByte(Serializer.DEFAULT.getSerializerAlgorithm());<br>    byteBuf.writeByte(packet.getCommand());<br>    byteBuf.writeInt(bytes.length);<br>    byteBuf.writeBytes(bytes);<br>    <span class="hljs-keyword">return</span> byteBuf;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码过程分为3个步骤。</p><ul><li>我们需要创建一个ByteBuf，这里我们调用Netty的ByteBuf分配器来创建，ioBuffer()方法会返回适配IO读写相关的内存，它会尽可能创建一个直接内存。直接内存可以理解为不受JVM堆管理的内存空间，写到IO缓冲区的效果更高。</li><li>将Java对象序列化成二进制数据包。</li><li>我们对照本章开头的协议设计和上一章ByteBuf的API，逐个往ByteBuf写入字段，即实现了编码过程。到此，编码过程结束。</li></ul><p>一端实现编码之后，Netty会将此ByteBuf写到另一端。另一端获得的也是一个ByteBuf对象。基于这个ByteBuf对象，就可以反解出在对端创建的Java对象，这个过程被称作解码，下面我们就来分析这个过程。</p><h3 id="8-3-4-解码：解析Java对象的过程"><a href="#8-3-4-解码：解析Java对象的过程" class="headerlink" title="8.3.4　解码：解析Java对象的过程"></a>8.3.4　解码：解析Java对象的过程</h3><p><strong>PacketCodeC.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Packet <span class="hljs-title function_">decode</span><span class="hljs-params">(ByteBuf byteBuf)</span> &#123;<br>    <span class="hljs-comment">// 跳过魔数    </span><br>    byteBuf.skipBytes(<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">// 跳过版本号    </span><br>    byteBuf.skipBytes(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 序列化算法标识    </span><br>    <span class="hljs-type">byte</span> <span class="hljs-variable">serializeAlgorithm</span> <span class="hljs-operator">=</span> byteBuf.readByte();<br>    <span class="hljs-comment">// 指令    </span><br>    <span class="hljs-type">byte</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> byteBuf.readByte();<br>    <span class="hljs-comment">// 数据包长度    </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> byteBuf.readInt();<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>    byteBuf.readBytes(bytes);<br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Packet</span>&gt; requestType = getRequestType(command);<br>    <span class="hljs-type">Serializer</span> <span class="hljs-variable">serializer</span> <span class="hljs-operator">=</span> getSerializer(serializeAlgorithm);<br>    <span class="hljs-keyword">if</span><br>        (requestType != <span class="hljs-literal">null</span> &amp;&amp; serializer != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> serializer.deserialize(requestType, bytes);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Packet</span>&gt; getRequestType(<span class="hljs-type">byte</span> command) &#123;<br>    <span class="hljs-keyword">return</span> REQUEST_TYPE_MAP.get(command);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Serializer <span class="hljs-title function_">getSerializer</span><span class="hljs-params">(<span class="hljs-type">byte</span> serializerAlgorithm)</span> &#123;<br>    <span class="hljs-keyword">if</span> (serializerAlgorithm == SerializerAlgorithm.JSON) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONSerializer</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解码的流程如下。</p><ul><li>我们假定decode方法传递进来的ByteBuf已经是合法的（后面我们再来实现校验），即首个4字节是我们定义的魔数0x12345678，这里我们调用skipBytes跳过这个4字节。</li><li>我们暂时不关注协议版本，通常在没有遇到协议升级的时候，暂时不处理这个字段。因为在绝大多数情况下，几乎用不着这个字段，但仍然需要暂时保留。</li><li>我们调用ByteBuf的API分别获得序列化算法标识、指令、数据包的长度。</li><li>我们根据获得的数据包的长度取出数据，通过指令获得该数据包对应的Java对象的类型，根据序列化算法标识获得序列化对象，将字节数组转换为Java对象。至此，解码过程结束。</li></ul><p>由此可以看到，解码过程与编码过程正好是相反的过程。</p><h2 id="8-4-总结"><a href="#8-4-总结" class="headerlink" title="8.4　总结"></a>8.4　总结</h2><p>本章，我们学到了以下几个知识点。</p><ul><li>通信协议是为了客户端与服务端交互，双方协商出来的满足一定规则的二进制数据格式。</li><li>介绍了一种通用的通信协议的设计，包括魔数、版本号、序列化算法标识、指令、数据长度、数据几个字段，该协议能够满足绝大多数通信场景。</li><li>Java对象及序列化的目的就是实现Java对象与二进制数据的互转。</li><li>我们依照设计的协议和ByteBuf的API实现了通信协议，这个过程被称为编解码过程。</li></ul><h2 id="8-5-思考"><a href="#8-5-思考" class="headerlink" title="8.5　思考"></a>8.5　思考</h2><ul><li>除了JSON序列化方式，还有哪些序列化方式？如何实现？</li><li>序列化和编码都是把Java对象封装成二进制数据的过程，这两者有什么区别和联系？</li></ul><h1 id="第-9-章-实现客户端登录"><a href="#第-9-章-实现客户端登录" class="headerlink" title="第 9 章 实现客户端登录"></a>第 9 章 实现客户端登录</h1><p>本章我们来实现客户端登录到服务端的过程。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0/%E5%BC%80%E5%8F%91/">开发</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Java/">Java</a> <a class="hover-with-bg" href="/tags/Netty/">Netty</a></div></div><p class="note note-warning"> 本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"></article><article class="post-next col-6"> <a href="/2022/08/05/Netty%E8%A7%A3%E5%86%B3%E7%9B%91%E6%8E%A7%E4%BC%A0%E8%BE%93%E3%80%81%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C/"><span class="hidden-mobile">Netty解决监控传输、指令操作</span> <span class="visible-mobile">下一篇</span><i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"> <span id="leancloud-site-pv-container" style="display:none">总访问量<span id="leancloud-site-pv"></span> 次</span> <span id="leancloud-site-uv-container" style="display:none">总访客数<span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js"></script><script defer="defer" src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script defer="defer" src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"default"})</script><script src="/js/boot.js"></script></body></html>