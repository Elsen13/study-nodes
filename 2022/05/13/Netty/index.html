<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/avatar.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Anrozz炫"><meta name="keywords" content=""><meta name="description" content="学会使用netty并调优"><meta property="og:type" content="article"><meta property="og:title" content="Netty"><meta property="og:url" content="https://study-nodes.vercel.app/2022/05/13/Netty/index.html"><meta property="og:site_name" content="AnrozzX"><meta property="og:description" content="学会使用netty并调优"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/cover/Netty.jpg"><meta property="article:published_time" content="2022-05-13T02:19:00.000Z"><meta property="article:modified_time" content="2022-08-09T12:24:17.380Z"><meta property="article:author" content="Anrozz炫"><meta property="article:tag" content="Java"><meta property="article:tag" content="Netty"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/cover/Netty.jpg"><title>Netty - AnrozzX</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"study-nodes.vercel.app",root:"/",version:"1.8.14",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"WjHIDOqzb1daY6OtrltW0izN-gzGzoHsz",app_key:"BmmacmxlOzYnoNfkcBoAMO16",server_url:null,path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/"><strong>Anrozz炫の博客</strong></a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"> <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/cover/Netty.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Netty"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Anrozz炫</span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-05-13 10:19" pubdate>2022年5月13日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字</span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 95 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Netty</h1><div class="markdown-body"><p><strong>学会使用netty并调优</strong></p><span id="more"></span><p>学自《跟闪电侠学 Netty：Netty 即时聊天实战与底层原理》</p><blockquote><p>文档更新于: 2022-8-9 19:51</p></blockquote><h1 id="第-1-章-即时聊天系统简介"><a href="#第-1-章-即时聊天系统简介" class="headerlink" title="第 1 章 即时聊天系统简介"></a>第 1 章 即时聊天系统简介</h1><p>​ 移动互联网时代，相信大家应该都对即时聊天工具不陌生，比如最常用的微信，从2011年1月21日诞生至今，已经成为国内数亿用户必不可少的即时通信工具，是男女老少手机中必备的顶级App。Netty是一个异步基于事件驱动的高性能网络通信框架，在互联网中间件领域网络通信层是无可争议的最强王者。在本书中，笔者将带领大家使用Netty一步一步实现即时聊天工具的核心功能。<br>即时聊天通常分为单聊和群聊，下面分别来介绍一下。</p><h2 id="1-1单聊流程"><a href="#1-1单聊流程" class="headerlink" title="1.1	单聊流程"></a>1.1 单聊流程</h2><p>​ 单聊指两个用户之间相互聊天。用户单聊的基本流程如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit.jpeg" srcset="/img/loading.gif" lazyload alt="用户单聊的基本流程"></p><ol><li>A要和B聊天，首先A和B需要与服务端建立连接，然后进入登录流程，服务端保存用户标识和TCP连接的映射关系。</li><li>A给B发消息，首先需要将带有B标识的消息数据包发送到服务端，然后服务端从消息数据包中获得B的标识，找到对应B的连接，将消息发送给B。</li><li>任意一方发消息给对方，如果对方不在线，则需要将消息缓存，在对方上线之后再发送。<br>客户端与服务端之间相互通信的数据包被称为指令数据包。指令数据包分为指令和数据，每一种指令都对应客户端或者服务端的一种操作，数据部分对应的是指令处理需要的数据。</li></ol><p><strong>问题</strong>：要实现单聊，客户端与服务端分别要实现哪些指令呢？</p><h2 id="1-2单聊的指令"><a href="#1-2单聊的指令" class="headerlink" title="1.2	单聊的指令"></a>1.2 单聊的指令</h2><h3 id="1-2-1-指令图示"><a href="#1-2-1-指令图示" class="headerlink" title="1.2.1　指令图示"></a>1.2.1　指令图示</h3><p>​ 下图是客户端与服务端单聊的指令流程图。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600447829622.jpeg" srcset="/img/loading.gif" lazyload alt="客户端与服务端单聊的指令流程图"></p><h3 id="1-2-2-指令列表"><a href="#1-2-2-指令列表" class="headerlink" title="1.2.2　指令列表"></a>1.2.2　指令列表</h3><p>​ 下表是要实现的单聊的指令列表，每条指令都会分为客户端和服务端。</p><table><thead><tr><th align="center">指令内容</th><th align="center">客户端</th><th align="center">服务端</th></tr></thead><tbody><tr><td align="center">登录请求</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">登录响应</td><td align="center">接收</td><td align="center">发送</td></tr><tr><td align="center">客户端发消息</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">服务端发消息</td><td align="center">接收</td><td align="center">发送</td></tr><tr><td align="center">登出请求</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">登出响应</td><td align="center">接收</td><td align="center">发送</td></tr></tbody></table><h2 id="1-3-群聊流程"><a href="#1-3-群聊流程" class="headerlink" title="1.3　群聊流程"></a>1.3　群聊流程</h2><p>​ 群聊指一个组内多个用户之间的聊天，一个用户发到群组的消息会被组内任何一个成员接收，群聊的基本流程如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600450111174.jpeg" srcset="/img/loading.gif" lazyload alt="群聊的基本流程"></p><p>​ 要实现群聊，其实流程和单聊类似。</p><ol><li>A、B、C依然会经历登录流程，服务端保存用户标识对应的TCP连接。</li><li>A发起群聊的时候，将A、B、C的标识发送至服务端，服务端拿到标识之后建立一个群ID，然后把这个ID与A、B、C的标识绑定。</li><li>群聊中任意一方在群里聊天的时候，将群ID发送至服务端，服务端获得群ID之后，取出对应的用户标识，遍历用户标识对应的TCP连接，就可以将消息发送至每一个群聊成员。</li></ol><p><strong>问题</strong>：群聊除了需要实现上述指令，还需要实现哪些指令呢？</p><h2 id="1-4-群聊要实现的指令集"><a href="#1-4-群聊要实现的指令集" class="headerlink" title="1.4　群聊要实现的指令集"></a>1.4　群聊要实现的指令集</h2><h3 id="1-4-1-指令图示"><a href="#1-4-1-指令图示" class="headerlink" title="1.4.1　指令图示"></a>1.4.1　指令图示</h3><p>​ 群聊的指令图示如下图所示。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600450823416.jpeg" srcset="/img/loading.gif" lazyload alt="群聊的指令图示"></p><h3 id="1-4-2-指令列表"><a href="#1-4-2-指令列表" class="headerlink" title="1.4.2　指令列表"></a>1.4.2　指令列表</h3><p>​ 群聊的指令如下表所示。</p><table><thead><tr><th align="center">指令内容</th><th align="center">客户端</th><th align="center">服务端</th></tr></thead><tbody><tr><td align="center">创建群聊请求</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">群聊创建成功通知</td><td align="center">接收</td><td align="center">发送</td></tr><tr><td align="center">加入群聊请求</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">群聊加入通知</td><td align="center">接收</td><td align="center">发送</td></tr><tr><td align="center">发送群聊消息</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">接收群聊消息</td><td align="center">接收</td><td align="center">发送</td></tr><tr><td align="center">退出群聊请求</td><td align="center">发送</td><td align="center">接收</td></tr><tr><td align="center">退出群聊通知</td><td align="center">接收</td><td align="center">发送</td></tr></tbody></table><h2 id="1-5-Netty"><a href="#1-5-Netty" class="headerlink" title="1.5　Netty"></a>1.5　Netty</h2><p>​ 使用 Netty 统一的 IO 读写 API 以及强大的 Pipeline 来编写业务处理逻辑，了解 Netty 以下核心知识点。<br><strong>●　如何启动服务端？</strong><br><strong>●　如何启动客户端？</strong><br><strong>●　数据载体 ByteBuf。</strong><br><strong>●　如何设计长连自定义协议？</strong><br><strong>●　拆包&#x2F;粘包原理与实践。</strong><br><strong>●　如何实现自定义编解码？</strong><br><strong>●　如何使用 Pipeline 与 ChannelHandler ？</strong><br><strong>●　如何定时发心跳数据包？</strong><br><strong>●　如何进行连接空闲检测？</strong></p><h3 id="1-5-1-客户端使用Netty的程序逻辑结构"><a href="#1-5-1-客户端使用Netty的程序逻辑结构" class="headerlink" title="1.5.1　客户端使用Netty的程序逻辑结构"></a>1.5.1　客户端使用Netty的程序逻辑结构</h3><p>​ 下图展示了客户端使用Netty的程序逻辑结构。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-16600453337568.jpeg" srcset="/img/loading.gif" lazyload alt="客户端Netty的程序逻辑结构"></p><ol><li>客户端会解析控制台指令，比如发送消息或者建立群聊等指令。</li><li>客户端会基于控制台的输入创建一个指令对象，用户告诉服务端具体要干什么事情。</li><li>TCP通信需要的数据格式为二进制，因此，接下来通过自定义二进制协议将指令对象封装成二进制，这一步被称为协议的编码。</li><li>对于收到服务端的数据，首先需要截取出一段完整的二进制数据包。</li><li>将此二进制数据包解析成指令对象，比如收到消息。</li><li>将指令对象送到对应的逻辑处理器来处理。</li></ol><h3 id="1-5-2-服务端使用Netty的程序逻辑结构"><a href="#1-5-2-服务端使用Netty的程序逻辑结构" class="headerlink" title="1.5.2　服务端使用Netty的程序逻辑结构"></a>1.5.2　服务端使用Netty的程序逻辑结构</h3><p>​ 服务端使用Netty的程序逻辑结构与客户端非常类似，如下图所示，这里不再赘述。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166004539765910.jpeg" srcset="/img/loading.gif" lazyload alt="服务端Netty的程序逻辑结构"></p><h2 id="1-6-实现的即时聊天形式"><a href="#1-6-实现的即时聊天形式" class="headerlink" title="1.6　实现的即时聊天形式"></a>1.6　实现的即时聊天形式</h2><p>以讲授Netty基础知识为主，故不会涉及即时聊天相关的图形化界面，后续所有的聊天都基于控制台进行，通过与控制台交互可以实现单聊和群聊。</p><h1 id="第-2-章-Netty-是什么"><a href="#第-2-章-Netty-是什么" class="headerlink" title="第 2 章 Netty 是什么"></a>第 2 章 Netty 是什么</h1><p>​ 在开始了解Netty是什么之前，我们先来回顾一下，如果需要实现一个客户端与服务端通信的程序，使用传统的IO编程，应该如何来实现？</p><h2 id="2-1-IO编程"><a href="#2-1-IO编程" class="headerlink" title="2.1　IO编程"></a>2.1　IO编程</h2><p>​ 我们简化一下场景：客户端每隔两秒发送一个带有时间戳的“hello world”给服务端，服务端收到之后打印它。<br>​ 为了方便演示，在下面的例子中，服务端和客户端各有一个类，把这两个类复制到你的IDE中，先后运行 IOServer.java 和 IOClient.java ，可以看到效果。<br>​ 下面是传统的IO编程中的服务端实现。</p><p>​ <strong>IOServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IOServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8000</span>);        <br>        <span class="hljs-comment">// 接收新连接线程        </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// (1)阻塞方法获取新连接</span><br>                    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                    <span class="hljs-comment">// (2)为每一个新连接都创建一个新线程，负责读取数据</span><br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-type">int</span> len;<br>                            <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>                            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>                            <span class="hljs-comment">// (3)按字节流方式读取数据</span><br>                            <span class="hljs-keyword">while</span> ((len = inputStream.read(data)) != -<span class="hljs-number">1</span>) &#123;<br>                                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data, <span class="hljs-number">0</span>, len));<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        &#125;<br>                    &#125;).start();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 服务端首先创建一个serverSocket来监听8000端口，然后创建一个线程，线程里不断调用阻塞方法serverSocket.accept()获取新连接，见（1）；当获得新连接之后，为每一个新连接都创建一个新线程，这个线程负责从该连接中读取数据，见（2）；然后以字节流方式读取数据，见（3）。<br>​ 下面是传统的IO编程中的客户端实现。</p><p>​ <strong>IOClient.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IOClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>);<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        socket.getOutputStream().write((<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;： helloworld&quot;</span>).getBytes());<br>                        Thread.sleep(<span class="hljs-number">2000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 客户端的代码相对简单，连接上服务端8000端口之后，每隔两秒，我们都向服务端写一个带有时间戳的“hello world”。<br>​ IO编程模型在客户端较少的情况下运行良好，但是对于客户端比较多的业务来说，单机服务端可能需要支撑成千上万个连接，IO模型可能就不太合适了，我们来分析一下原因。<br>​ 在上面的示例中，从服务端代码可以看到，在传统的IO模型中，每个连接创建成功之后都需要由一个线程来维护，每个线程都包含一个while死循环，那么1万个连接对应1万个线程，继而有1万个 while 死循环，这就带来如下几个问题。</p><ol><li>线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态，是非常严重的资源浪费，操作系统耗不起。</li><li>线程切换效率低下：单机CPU核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。</li><li>除了以上两个问题，在IO编程中，我们看到数据读写是以字节流为单位的。</li></ol><p>​ 为了解决这3个问题，JDK在1.4版本之后提出了NIO。</p><h2 id="2-2-NIO编程"><a href="#2-2-NIO编程" class="headerlink" title="2.2　NIO编程"></a>2.2　NIO编程</h2><p>​ 网上有很多关于NIO的文章，这里不再深入分析。下面简单描述一下NIO是如何解决以上3个问题的。</p><h2 id="2-2-1-线程资源受限"><a href="#2-2-1-线程资源受限" class="headerlink" title="2.2.1　线程资源受限"></a>2.2.1　线程资源受限</h2><p>​ 在NIO编程模型中，新来一个连接不再创建一个新线程，而是可以把这个连接直接绑定到某个固定的线程，然后这个连接所有的读写都由这个线程来负责，那么它是怎么做到的？我们用下图来对比一下IO与NIO。</p><p><img src="https://edu-elsen.oss-cn-guangzhou.aliyuncs.com/study-nodes/Netty.assets/resize,w_1536,m_lfit-166004622917312.jpeg" srcset="/img/loading.gif" lazyload alt="IO与NIO"></p><p>​ 如上图所示，在IO模型中，一个连接来了，会创建一个线程，对应一个while死循环，死循环的目的就是不断监测这个连接上是否有数据可以读。在大多数情况下，1万个连接里面同一时刻只有少量的连接有数据可读，因此，很多while死循环都白白浪费掉了，因为读不出数据。<br>​ 而在NIO模型中，这么多while死循环转换为一个死循环，这个死循环由一个线程控制，那么NIO又是如何做到一个线程一个while死循环就能监测1万个连接是否有数据可读的呢？<br>​ 这就是NIO模型中Selector的作用，一个连接来了之后，不会创建一个while死循环去监听是否有数据可读，而是直接把这条连接注册到Selector上。然后，通过检查这个Selector，就可以批量监测出有数据可读的连接，进而读取数据。下面我们举一个生活中非常简单的例子来说明IO与NIO的区别。<br>​ 在一家幼儿园里，小朋友有上厕所的需求，小朋友都太小以至于你要问他要不要上厕所，他才会告诉你。幼儿园一共有100个小朋友，有两种方案可以解决小朋友上厕所的问题。</p><ol><li>每个小朋友都配一个老师。每个老师都隔段时间询问小朋友是否要上厕所。如果要上，就领他去厕所，100个小朋友就需要100个老师来询问，并且每个小朋友上厕所的时候都需要一个老师领着他去，这就是IO模型，一个连接对应一个线程。</li><li>所有的小朋友都配同一个老师。这个老师隔段时间询问所有的小朋友是否有人要上厕所，然后每一时刻把所有要上厕所的小朋友批量领到厕所，这就是NIO模型。所有小朋友都注册到同一个老师，对应的就是所有的连接都注册到同一个线程，然后批量轮询。</li></ol><p>​ 这就是NIO模型解决线程资源受限问题的方案。在实际开发过程中，我们会开多个线程，每个线程都管理着一批连接，相对于IO模型中一个线程管理一个连接，消耗的线程资源大幅减少。</p><h3 id="2-2-2-线程切换效率低下"><a href="#2-2-2-线程切换效率低下" class="headerlink" title="2.2.2　线程切换效率低下"></a>2.2.2　线程切换效率低下</h3><p>​ 由于NIO模型中线程数量大大降低，因此线程切换效率也大幅度提高。</p><h3 id="2-2-3-IO读写面向流"><a href="#2-2-3-IO读写面向流" class="headerlink" title="2.2.3　IO读写面向流"></a>2.2.3　IO读写面向流</h3><p>​ IO读写是面向流的，一次性只能从流中读取一字节或者多字节，并且读完之后流无法再读取，需要自己缓存数据。而NIO的读写是面向Buffer的，可以随意读取里面任何字节数据，不需要自己缓存数据，只需要移动读写指针即可。<br>​ 简单讲完了JDK NIO的解决方案之后，接下来我们使用NIO方案替换掉IO方案。先来看看，如果用JDK原生的NIO来实现服务端，该怎么做。<br>前方高能预警：以下代码可能会让你感觉极度不适，如有不适，请跳过。</p><p>​ <strong>NIOServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 闪电侠</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">serverSelector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">clientSelector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 对应IO编程中的服务端启动</span><br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">listenerChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>                listenerChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8000</span>));<br>                listenerChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">// 监测是否有新连接，这里的1指阻塞的时间为 1ms</span><br>                    <span class="hljs-keyword">if</span> (serverSelector.select(<span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                        Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();<br>                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();<br>                        <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>                            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>                            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-comment">// (1)每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector</span><br>                                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> ((ServerSocketChannel) key.channel()).accept();<br>                                    clientChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                                    clientChannel.register(clientSelector, SelectionKey.OP_READ);<br>                                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                                    keyIterator.remove();<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">// (2)批量轮询哪些连接有数据可读，这里的1指阻塞的时间为 1ms</span><br>                    <span class="hljs-keyword">if</span> (clientSelector.select(<span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                        Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();<br>                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();<br>                        <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>                            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>                            <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                                    <span class="hljs-comment">// (3)面向Buffer                                    </span><br>                                    clientChannel.read(byteBuffer);<br>                                    byteBuffer.flip();<br>                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer));<br>                                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                                    keyIterator.remove();<br>                                    key.interestOps(SelectionKey.OP_READ);<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相信大部分没有接触过NIO的读者应该会直接跳过代码来到这一行：原来使用JDK原生NIO的API实现一个简单的服务端通信程序如此复杂!<br>我们还是先对照NIO来解释一下核心思路。</p><ol><li>NIO模型中通常会有两个线程，每个线程都绑定一个轮询器Selector。在这个例子中，serverSelector负责轮询是否有新连接，clientSelector负责轮询连接是否有数据可读。</li><li>服务端监测到新连接之后，不再创建一个新线程，而是直接将新连接绑定到clientSelector上，这样就不用IO模型中的1万个while循环死等，参见（1）。</li><li>clientSelector被一个while死循环包裹着，如果在某一时刻有多个连接有数据可读，那么通过clientSelector.select(1)方法可以轮询出来，进而批量处理，参见（2）。</li><li>数据的读写面向Buffer，参见（3）。</li></ol><p>​ 其他细节部分，因为实在是太复杂，所以笔者不再多讲，读者也不用对代码的细节深究到底。总之，强烈不建议直接基于JDK原生NIO来进行网络开发，下面是笔者总结的原因。</p><ol><li>JDK的NIO编程需要了解很多概念，编程复杂，对NIO入门非常不友好，编程模型不友好，ByteBuffer的API简直“反人类”。</li><li>对NIO编程来说，一个比较合适的线程模型能充分发挥它的优势，而JDK没有实现，需要自己实现，就连简单的自定义协议拆包都要自己实现。</li><li>JDK的NIO底层由Epoll实现，该实现饱受诟病的空轮询Bug会导致CPU占用率飙升至100%。</li><li>项目庞大之后，自行实现的NIO很容易出现各类Bug，维护成本较高，上面这些代码笔者都不能保证没有Bug。</li></ol><p>​ 正因为如此，客户端代码这里就省略了，读者可以直接使用IOClient.java与NIOServer.java通信。<br>​ JDK的NIO犹如带刺的玫瑰，虽然美好，让人向往，但是使用不当会让你抓耳挠腮，痛不欲生，正因为如此，Netty横空出世！</p><h2 id="2-3-Netty编程"><a href="#2-3-Netty编程" class="headerlink" title="2.3　Netty编程"></a>2.3　Netty编程</h2><p>​ Netty到底是何方神圣？<br>​ 用一句简单的话来说就是：Netty封装了JDK的NIO，让你用得更方便，不用再写一大堆复杂的代码了。<br>​ 用官方正式的话来说就是：Netty是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务端和客户端。<br>​ 下面是笔者总结的使用Netty而不使用JDK原生NIO的原因。</p><ol><li>使用JDK原生NIO需要了解太多概念，编程复杂，一不小心就Bug横飞。</li><li>Netty底层IO模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从NIO模型变身为IO模型。</li><li>Netty自带的拆包&#x2F;粘包、异常检测等机制让你从NIO的繁重细节中脱离出来，只需要关心业务逻辑即可。</li><li>Netty解决了JDK很多包括空轮询在内的Bug。</li><li>Netty底层对线程、Selector做了很多细小的优化，精心设计的Reactor线程模型可以做到非常高效的并发处理。</li><li>自带各种协议栈，让你处理任何一种通用协议都几乎不用亲自动手。</li><li>Netty社区活跃，遇到问题随时邮件列表或者Issue。</li><li>Netty已经历各大RPC框架、消息中间件、分布式通信中间件线上的广泛验证，健壮性无比强大。</li></ol><p>​ 这些原因看不懂没有关系，在后续的章节中我们都可以学到。接下来我们用Netty来重新实现一下本章开篇的功能吧！<br>首先引入Maven依赖，本书后续Netty都基于4.1.6.Final版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.6.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​ 然后是服务端实现部分。</p><p>​ <strong>NettyServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        serverBootstrap<br>                .group(boss, worker)<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> &#123;<br>                                System.out.println(msg);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;).bind(<span class="hljs-number">8000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 这么一小段代码就实现了我们前面NIO编程中的所有功能，包括服务端启动、接收新连接、打印客户端传来的数据，怎么样？是不是比JDK原生NIO编程简洁许多？<br>初学Netty的时候，由于大部分人对NIO编程缺乏经验，因此，将Netty里的概念与IO模型结合起来可能更好理解。</p><ol><li>boss对应IOServer.java中的负责接收新连接的线程，主要负责创建新连接。</li><li>worker对应IOServer.java中的负责读取数据的线程，主要用于读取数据及业务逻辑处理。</li></ol><p>​ 剩下的逻辑笔者在后面的内容中会详细分析，读者可以先把这段代码复制到自己的IDE里，然后运行main函数。<br>​ 下面是客户端NIO的实现部分。</p><p>​ <strong>NettyClient.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.Channel;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<br><br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        bootstrap<br>                .group(group)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(Channel ch)</span> &#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>).channel();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            channel.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;： hello world！&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 在客户端程序中，group对应了IOClient.java中main函数起的线程，剩下的逻辑在后面的内容中会详细分析，现在你要做的事情就是把这段代码复制到你的IDE里，然后运行main函数，最后回到NettyServer.java的控制台，你会看到效果。<br>​ 使用Netty之后是不是觉得整个世界都变美好了？一方面，Netty对NIO封装得如此完美，写出来的代码非常优雅；另一方面，使用Netty之后，网络通信的性能问题几乎不用操心，尽情地让Netty“榨干”你的CPU吧。</p><h1 id="第-3-章-Netty-开发环境配置"><a href="#第-3-章-Netty-开发环境配置" class="headerlink" title="第 3 章 Netty 开发环境配置"></a>第 3 章 Netty 开发环境配置</h1><p>​ 本章介绍Netty开发环境的搭建，笔者假设读者已经有了Java编程需要的环境。如果读者已经安装过Maven、Git、IntelliJ IDEA环境，建议直接看本章末尾的“如何使用本书的代码”。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0/%E5%BC%80%E5%8F%91/">开发</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Java/">Java</a> <a class="hover-with-bg" href="/tags/Netty/">Netty</a></div></div><p class="note note-warning"> 本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2022/08/04/Elasticsearch/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Elasticsearch、Logstash、Kibana</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"> <a href="/2022/05/06/%E5%91%A8%E6%80%BB%E7%BB%93/"><span class="hidden-mobile">周总结</span> <span class="visible-mobile">下一篇</span><i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"> <span id="leancloud-site-pv-container" style="display:none">总访问量<span id="leancloud-site-pv"></span> 次</span> <span id="leancloud-site-uv-container" style="display:none">总访客数<span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js"></script><script defer="defer" src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script defer="defer" src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"default"})</script><script src="/js/boot.js"></script></body></html>